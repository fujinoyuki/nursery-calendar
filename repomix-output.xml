This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  _logout/
    page.tsx
  api/
    admin/
      route.ts
    route.ts
  auth/
    callback/
      route.ts
  components/
    EventCard/
      index.tsx
      styles.module.css
      styles.module.css.d.ts
    AddEventForm.module.css
    AddEventForm.module.css.d.ts
    AddEventForm.tsx
    AuthButton.module.css
    AuthButton.tsx
    AuthForm.module.css
    AuthForm.tsx
    EditEventForm.module.css
    EditEventForm.module.css.d.ts
    EditEventForm.tsx
    EventCard.module.css.d.ts
    EventOverlay.module.css
    EventOverlay.tsx
    MonthCard.module.css
    MonthCard.module.css.d.ts
    MonthCard.tsx
  events/
    edit/
      [id]/
        page.module.css
        page.tsx
    page.module.css
    page.module.css.d.ts
    page.tsx
  lib/
    auth.tsx
    supabase.ts
  main/
    main.module.css
    page.module.css
    page.module.css.d.ts
    page.tsx
  styles/
    EditEventForm.module.css
    globals.css
  types/
    css.d.ts
    event.ts
    index.ts
  utils/
    constants.ts
  globals.css
  layout.tsx
  page.module.css
  page.tsx
  providers.tsx
  types.ts
docs/
  supabase-setup.md
public/
  images/
    placeholder.svg
supabase/
  .gitignore
  config.toml
utils/
  supabase.ts
.cspell.json
.gitignore
middleware.ts
next.config.js
package.json
README.md
setup.sql
storage_setup.sql
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="storage_setup.sql">
-- event-mediaバケットの作成（既に存在する場合はエラーになるため、必要に応じて実行）
INSERT INTO storage.buckets (id, name, public)
VALUES ('event-media', 'event-media', true);

-- event-mediaバケットへの認証済みユーザーのアクセス権限設定
-- 認証済みユーザーに完全な権限を与える
INSERT INTO storage.policies (name, definition, bucket_id)
VALUES (
  'Authenticated users can upload media',
  '(auth.role() = ''authenticated'')',
  'event-media'
);

-- イベント画像への公開アクセス権限設定
INSERT INTO storage.policies (name, definition, bucket_id, operation)
VALUES (
  'Public access to media files',
  'true',
  'event-media',
  'read'
);

-- 認証済みユーザーが自分自身のフォルダにのみアップロードできるポリシー
INSERT INTO storage.policies (name, definition, bucket_id, operation)
VALUES (
  'Users can only upload to their own folder',
  '((auth.uid())::text = (storage.foldername(name))[1])',
  'event-media',
  'insert'
);

-- 認証済みユーザーが自分自身のフォルダのファイルを削除できるポリシー
INSERT INTO storage.policies (name, definition, bucket_id, operation)
VALUES (
  'Users can only delete from their own folder',
  '((auth.uid())::text = (storage.foldername(name))[1])',
  'event-media',
  'remove'
);
</file>

<file path="app/_logout/page.tsx">
'use client';

import { useEffect } from 'react';
import { createBrowserClient } from '@supabase/ssr';

export default function LogoutPage() {
  useEffect(() => {
    const performLogout = async () => {
      // Supabaseインスタンスの作成
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
      
      try {
        // まずローカルでサインアウト
        await supabase.auth.signOut({ scope: 'local' });
      } catch (error) {
        console.error('ログアウトエラー:', error);
      }
      
      // クッキーをクリア
      document.cookie.split(";").forEach(c => {
        document.cookie = c.trim().split("=")[0] + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
      });
      
      // ローカルストレージをクリア
      localStorage.clear();
      
      // ホームページへリダイレクト
      window.location.href = '/';
    };
    
    performLogout();
  }, []);
  
  return <div>ログアウト中...</div>;
}
</file>

<file path="app/api/admin/route.ts">
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json({ error: '認証されていません' }, { status: 401 });
    }
    
    // ここで管理者かどうかを確認
    const { data: user } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .single();
    
    if (user?.role !== 'admin') {
      return NextResponse.json({ error: '権限がありません' }, { status: 403 });
    }
    
    // 管理者機能の実装
    // 例: ユーザー一覧の取得
    const { data: users, error } = await supabase
      .from('profiles')
      .select('*');
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json({ users });
    
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
</file>

<file path="app/api/route.ts">
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json({ error: '認証されていません' }, { status: 401 });
    }
    
    // イベントデータの取得
    const { data: events, error } = await supabase
      .from('events')
      .select('*')
      .order('month', { ascending: true });
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json({ events });
    
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json({ error: '認証されていません' }, { status: 401 });
    }
    
    const body = await request.json();
    const { title, description, month, date } = body;
    
    if (!title || !description || !month || !date) {
      return NextResponse.json({ error: '必須フィールドが不足しています' }, { status: 400 });
    }
    
    // イベントの作成
    const { data, error } = await supabase
      .from('events')
      .insert([
        { 
          title, 
          description, 
          month, 
          date,
          user_id: session.user.id
        }
      ])
      .select();
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json({ event: data[0] });
    
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export async function PUT(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json({ error: '認証されていません' }, { status: 401 });
    }
    
    const body = await request.json();
    const { id, title, description, month, date } = body;
    
    if (!id || !title || !description || !month || !date) {
      return NextResponse.json({ error: '必須フィールドが不足しています' }, { status: 400 });
    }
    
    // イベントの更新
    const { data, error } = await supabase
      .from('events')
      .update({ title, description, month, date })
      .eq('id', id)
      .eq('user_id', session.user.id)
      .select();
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    if (data.length === 0) {
      return NextResponse.json({ error: 'イベントが見つからないか、編集権限がありません' }, { status: 404 });
    }
    
    return NextResponse.json({ event: data[0] });
    
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json({ error: '認証されていません' }, { status: 401 });
    }
    
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json({ error: 'イベントIDが必要です' }, { status: 400 });
    }
    
    // イベントの削除
    const { error } = await supabase
      .from('events')
      .delete()
      .eq('id', id)
      .eq('user_id', session.user.id);
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json({ success: true });
    
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
</file>

<file path="app/components/EventCard/index.tsx">
import React from 'react';
import Image from 'next/image';
import styles from './styles.module.css';
import { Event, AgeGroup } from '../../types';

interface EventCardProps {
  event: Event;
  onClick: (event: Event) => void;
}

// 年齢グループをソートする関数
const sortAgeGroups = (ages: AgeGroup[] = []) => {
  const ageOrder: AgeGroup[] = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'];
  return [...ages].sort((a, b) => ageOrder.indexOf(a) - ageOrder.indexOf(b));
};

// カテゴリースタイルを取得する関数
const getCategoryStyle = (category: string): string => {
  const normalizedCategory = category?.replace(/\s+/g, '').trim();
  if (['壁面', '壁　面'].includes(normalizedCategory)) {
    return styles.wallColumn;
  }
  if (['制作物', '製作', 'アート'].includes(normalizedCategory)) {
    return styles.craftColumn;
  }
  return styles.otherColumn;
};

// 所要時間をフォーマットする関数
const formatDuration = (duration: { start?: string, end?: string } | string | null | undefined) => {
  // 値が存在しない場合
  if (!duration) return '不明';
  
  // 文字列の場合はJSONとしてパース
  if (typeof duration === 'string') {
    try {
      const parsedDuration = JSON.parse(duration);
      return formatDuration(parsedDuration);
    } catch (e) {
      // 時間と分を抽出（例: "2時間30分"）
      const durationStr = duration as string;
      const hoursMatch = durationStr.match(/(\d+)時間/);
      const minutesMatch = durationStr.match(/(\d+)分/);
      
      if (hoursMatch || minutesMatch) {
        const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
        const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
        
        if (hours > 0 && minutes > 0) {
          return `${hours}時間${minutes}分`;
        } else if (hours > 0) {
          return `${hours}時間`;
        } else if (minutes > 0) {
          return `${minutes}分`;
        }
      }
      return durationStr;
    }
  }
  
  // オブジェクトの場合はend値を使う
  const durationObj = duration as { start?: string, end?: string };
  const end = durationObj.end;
  if (!end) return '不明';
  
  // HH:MM形式の場合
  const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1]);
    const minutes = parseInt(timeMatch[2]);
    
    if (hours > 0 && minutes > 0) {
      return `${hours}時間${minutes}分`;
    } else if (hours > 0) {
      return `${hours}時間`;
    } else if (minutes > 0) {
      return `${minutes}分`;
    }
  }
  
  return end;
};

const EventCard: React.FC<EventCardProps> = ({ event, onClick }) => {
  return (
    <div className={styles.eventCard} onClick={() => onClick(event)}>
      {/* 1. 画像エリア */}
      <div className={styles.imageContainer}>
        {event.image_url ? (
          <Image
            src={event.image_url}
            alt={event.title}
            className={styles.eventImage}
            fill
            sizes="300px"
          />
        ) : (
          <div className={styles.noImage}>NO IMAGE</div>
        )}
      </div>
      
      <div className={styles.contentContainer}>
        {/* 2. タイトルとカテゴリー */}
        <div className={styles.titleRow}>
          <div className={`${styles.categoryLabel} ${getCategoryStyle(event.category)}`}>
            {event.category}
          </div>
          <h3 className={styles.title}>{event.title}</h3>
        </div>

        {/* 3. 年齢タグ */}
        <div className={styles.ageTags}>
          {sortAgeGroups(event.age_groups).map((age, index) => (
            <span 
              key={`${age}-${index}`} 
              className={styles.ageTag}
              data-age={age}
            >
              {age}
            </span>
          ))}
        </div>

        {/* 4. 月と所要時間 */}
        <div className={styles.footer}>
          <span className={styles.month}>{event.month}月</span>
          <span className={styles.duration}>所要時間：{formatDuration(event.duration)}</span>
        </div>
      </div>
    </div>
  );
};

export default EventCard;
</file>

<file path="app/components/EventCard/styles.module.css">
.eventCard {
  background: white;
  border-radius: 15px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  transition: all 0.3s ease;
  width: 300px;
  height: 700px;
  display: flex;
  flex-direction: column;
}

.eventCard:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
}

.imageContainer {
  width: 100%;
  height: 250px;
  position: relative;
  background: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: center;
}

.eventImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.noImage {
  color: #999;
  font-size: 1.2rem;
  font-weight: 500;
}

.contentContainer {
  flex: 1;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.titleRow {
  display: flex;
  align-items: center;
  gap: 12px;
}

.categoryLabel {
  font-size: 0.85rem;
  padding: 4px 10px;
  border-radius: 20px;
  color: white;
  font-weight: 500;
  white-space: nowrap;
}

.title {
  margin: 0;
  color: #333;
  font-weight: 600;
  font-size: 1.1rem;
  flex: 1;
  display: -webkit-box;
  -webkit-line-clamp: 1;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.wallColumn {
  background: #A7D2FF;
}

.craftColumn {
  background: #FFB5C5;
}

.otherColumn {
  background: #B5E6B5;
}

.ageTags {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.ageTag {
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: 500;
  transition: all 0.3s ease;
}

.ageTag[data-age="0歳児"] {
  background-color: rgba(255, 182, 193, 0.2);
  color: #d4788f;
}

.ageTag[data-age="1歳児"] {
  background-color: rgba(255, 218, 185, 0.2);
  color: #d49a6a;
}

.ageTag[data-age="2歳児"] {
  background-color: rgba(176, 224, 230, 0.2);
  color: #6a9da3;
}

.ageTag[data-age="3歳児"] {
  background-color: rgba(144, 238, 144, 0.2);
  color: #5fa55f;
}

.ageTag[data-age="4歳児"] {
  background-color: rgba(230, 230, 250, 0.2);
  color: #8484b4;
}

.ageTag[data-age="5歳児"] {
  background-color: rgba(255, 239, 213, 0.2);
  color: #d4b48c;
}

.footer {
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.month {
  font-size: 0.9rem;
  color: #666;
  padding: 4px 8px;
  background-color: rgba(96, 165, 250, 0.1);
  border-radius: 12px;
  white-space: nowrap;
}

.duration {
  font-size: 0.9rem;
  color: #666;
  padding: 4px 8px;
  background-color: rgba(96, 165, 250, 0.1);
  border-radius: 12px;
  white-space: nowrap;
  margin-left: auto;
}
</file>

<file path="app/components/EventCard/styles.module.css.d.ts">
declare const styles: {
  readonly eventCard: string;
  readonly imageContainer: string;
  readonly eventImage: string;
  readonly noImage: string;
  readonly contentContainer: string;
  readonly titleRow: string;
  readonly title: string;
  readonly categoryLabel: string;
  readonly wallColumn: string;
  readonly craftColumn: string;
  readonly otherColumn: string;
  readonly ageTags: string;
  readonly ageTag: string;
  readonly footer: string;
  readonly month: string;
  readonly duration: string;
};

export default styles;
</file>

<file path="app/components/AddEventForm.module.css.d.ts">
declare const styles: {
  readonly [key: string]: string;
};

export default styles;
</file>

<file path="app/components/AuthButton.module.css">
.button {
  padding: 0.75rem 1.5rem;
  background-color: #FF6B6B;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.button:hover {
  background-color: #FF5252;
  transform: translateY(-2px);
  box-shadow: 0 2px 4px rgba(255, 107, 107, 0.3);
}
</file>

<file path="app/components/AuthForm.module.css">
.authContainer {
  max-width: 400px;
  margin: 0 auto;
  padding: 2rem;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  background-color: white;
}

.formTitle {
  text-align: center;
  margin-bottom: 2rem;
  font-size: 1.5rem;
  color: #333;
}

.formGroup {
  margin-bottom: 1.5rem;
}

.label {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  color: #555;
}

.input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
}

.input:focus {
  outline: none;
  border-color: #87CEEB;
  box-shadow: 0 0 0 2px rgba(135, 206, 235, 0.2);
}

.button {
  width: 100%;
  padding: 0.75rem;
  border: none;
  border-radius: 4px;
  background-color: #87CEEB;
  color: white;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.3s;
}

.button:hover {
  background-color: #75BCD6;
}

.button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.buttonText {
  font-weight: bold;
}

.errorMessage {
  background-color: #ffebee;
  color: #d32f2f;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1.5rem;
  font-size: 0.9rem;
}

.switchText {
  text-align: center;
  margin-top: 1.5rem;
  color: #87CEEB;
  cursor: pointer;
  font-size: 0.9rem;
}

.switchText:hover {
  text-decoration: underline;
}
</file>

<file path="app/components/EditEventForm.module.css.d.ts">
declare const styles: {
  readonly [key: string]: string;
};

export default styles;
</file>

<file path="app/components/EventCard.module.css.d.ts">
declare const styles: {
  readonly eventCard: string;
  readonly imageContainer: string;
  readonly eventImage: string;
  readonly noImage: string;
  readonly contentContainer: string;
  readonly header: string;
  readonly categoryLabel: string;
  readonly wallColumn: string;
  readonly craftColumn: string;
  readonly otherColumn: string;
  readonly title: string;
  readonly description: string;
  readonly metaContainer: string;
  readonly ageTags: string;
  readonly ageTag: string;
  readonly duration: string;
};

export default styles;
</file>

<file path="app/components/MonthCard.module.css.d.ts">
declare const styles: {
  readonly [key: string]: string;
};

export default styles;
</file>

<file path="app/events/edit/[id]/page.module.css">
.container {
  max-width: 800px;
  margin: 2rem auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.title {
  font-size: 1.8rem;
  color: #333;
  margin-bottom: 2rem;
  text-align: center;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.formGroup label {
  font-size: 1rem;
  color: #555;
}

.input,
.textarea,
.select {
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
  width: 100%;
}

.textarea {
  min-height: 150px;
  resize: vertical;
}

.buttonGroup {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 2rem;
}

.submitButton,
.cancelButton {
  padding: 0.75rem 2rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

.submitButton {
  background-color: #4CAF50;
  color: white;
}

.submitButton:hover {
  background-color: #45a049;
}

.cancelButton {
  background-color: #f44336;
  color: white;
}

.cancelButton:hover {
  background-color: #da190b;
}
</file>

<file path="app/events/page.module.css.d.ts">
declare const styles: {
  readonly container: string;
  readonly contentWrapper: string;
  readonly springContainer: string;
  readonly springButton: string;
  readonly summerContainer: string;
  readonly summerButton: string;
  readonly autumnContainer: string;
  readonly autumnButton: string;
  readonly winterContainer: string;
  readonly winterButton: string;
  readonly header: string;
  readonly pageTitle: string;
  readonly headerButtons: string;
  readonly backButton: string;
  readonly logoutButton: string;
  readonly searchSection: string;
  readonly searchBar: string;
  readonly searchInput: string;
  readonly searchButtons: string;
  readonly searchButton: string;
  readonly advancedSearchButton: string;
  readonly sortContainer: string;
  readonly sortButton: string;
  readonly active: string;
  readonly eventsGrid: string;
  readonly eventCard: string;
  readonly eventImageContainer: string;
  readonly eventImage: string;
  readonly eventVideo: string;
  readonly eventContent: string;
  readonly eventHeader: string;
  readonly eventCategory: string;
  readonly eventTitle: string;
  readonly eventDescription: string;
  readonly ageGroups: string;
  readonly ageTag: string;
  readonly eventFooter: string;
  readonly month: string;
  readonly duration: string;
  readonly noImage: string;
  readonly categoryWall: string;
  readonly categoryArt: string;
  readonly categoryOther: string;
  readonly age0: string;
  readonly age1: string;
  readonly age2: string;
  readonly age3: string;
  readonly age4: string;
  readonly age5: string;
  readonly month1: string;
  readonly month2: string;
  readonly month3: string;
  readonly month4: string;
  readonly month5: string;
  readonly month6: string;
  readonly month7: string;
  readonly month8: string;
  readonly month9: string;
  readonly month10: string;
  readonly month11: string;
  readonly month12: string;
  readonly materials: string;
  readonly materialsLabel: string;
  [key: string]: string;
};

export default styles;
</file>

<file path="app/lib/auth.tsx">
'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';
import { createBrowserClient } from '@supabase/ssr';

export interface User {
  id: string;
  email: string;
  name?: string;
}

export interface AuthError {
  message: string;
  code?: string;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: AuthError | null;
  signIn: (email: string, password: string) => Promise<{ error?: AuthError }>;
  signUp: (email: string, password: string, name: string) => Promise<{ error?: AuthError }>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<AuthError | null>(null);

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  useEffect(() => {
    const initSession = async () => {
      try {
        const { data: { session }, error: sessionError } = await supabase.auth.getSession();
        if (sessionError) {
          console.error('Session error:', sessionError);
          return;
        }
        
        if (session?.user) {
          console.log('Session found:', session.user);
          setUser({
            id: session.user.id,
            email: session.user.email!,
            name: session.user.user_metadata?.name
          });
        } else {
          console.log('No session found');
        }
      } catch (err) {
        console.error('Session initialization error:', err);
      } finally {
        setLoading(false);
      }
    };

    initSession();

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log('Auth state changed:', event, session);
        if (session?.user) {
          setUser({
            id: session.user.id,
            email: session.user.email!,
            name: session.user.user_metadata?.name
          });
        } else {
          setUser(null);
        }
        setLoading(false);
      }
    );

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const signIn = async (email: string, password: string) => {
    try {
      console.log('Attempting sign in for:', email);
      setError(null);
      
      const { data, error: signInError } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      if (signInError) {
        console.error('Sign in error:', signInError);
        const authError: AuthError = {
          message: signInError.message,
          code: signInError.status?.toString()
        };
        setError(authError);
        return { error: authError };
      }
      
      if (data?.user) {
        console.log('Sign in successful:', data.user);
        const userData: User = {
          id: data.user.id,
          email: data.user.email!,
          name: data.user.user_metadata?.name,
        };
        setUser(userData);
        return {};
      } else {
        console.error('No user data received after sign in');
        return { error: { message: 'ユーザーデータが取得できませんでした' } };
      }
    } catch (err: any) {
      console.error('Unexpected sign in error:', err);
      const authError: AuthError = {
        message: err.message || 'ログインに失敗しました',
        code: err.code
      };
      setError(authError);
      return { error: authError };
    }
  };

  const signUp = async (email: string, password: string, name: string) => {
    try {
      setError(null);
      const { data, error: signUpError } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { name }
        }
      });

      if (signUpError) {
        const authError: AuthError = {
          message: signUpError.message,
          code: signUpError.status?.toString()
        };
        setError(authError);
        return { error: authError };
      }

      return {};
    } catch (err: any) {
      const authError: AuthError = {
        message: err.message || '登録に失敗しました',
        code: err.code
      };
      setError(authError);
      return { error: authError };
    }
  };

  const signOut = async () => {
    try {
      await supabase.auth.signOut();
      setUser(null);
    } catch (err: any) {
      console.error('Sign out error:', err);
    }
  };

  const value: AuthContextType = {
    user,
    loading,
    error,
    signIn,
    signUp,
    signOut,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
</file>

<file path="app/lib/supabase.ts">
import { createBrowserClient } from '@supabase/ssr';

export const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);
</file>

<file path="app/main/page.module.css.d.ts">
declare const styles: {
  readonly container: string;
  readonly loadingContainer: string;
  readonly loadingSpinner: string;
  readonly errorContainer: string;
  readonly retryButton: string;
  readonly feedbackMessage: string;
  readonly headerWrapper: string;
  readonly title: string;
  readonly headerButtons: string;
  readonly viewAllLink: string;
  readonly error: string;
  readonly success: string;
  readonly warning: string;
  readonly logoutButton: string;
  readonly descriptionContainer: string;
  readonly description: string;
  readonly eventsContainer: string;
  readonly monthContainer: string;
  readonly monthTitle: string;
  readonly eventList: string;
  readonly eventItem: string;
  readonly eventTitle: string;
  readonly eventDetails: string;
  readonly noEvents: string;
  readonly addButton: string;
  readonly overlay: string;
  readonly modal: string;
  readonly decorationDot: string;
  readonly monthCard: string;
  readonly monthHeader: string;
  readonly eventsList: string;
  readonly popularSection: string;
  readonly sectionTitle: string;
  readonly popularEvents: string;
  readonly popularEventCard: string;
  readonly popularEventHeader: string;
  readonly popularEventMonth: string;
  readonly popularEventViews: string;
  readonly popularEventTitle: string;
  readonly popularEventMeta: string;
  readonly popularEventAges: string;
  readonly popularEventAge: string;
  readonly monthGrid: string;
  readonly newEventAnimation: string;
  readonly header: string;
};

export default styles;
</file>

<file path="app/styles/EditEventForm.module.css">
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
}

.title {
  font-size: 2rem;
  margin-bottom: 2rem;
  text-align: center;
  color: #333;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.formGroup label {
  font-weight: 600;
  color: #444;
}

.input,
.textarea,
.select {
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
}

.textarea {
  min-height: 150px;
  resize: vertical;
}

.checkboxGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.checkbox {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.checkbox.selected {
  background-color: #e3f2fd;
  border-color: #2196f3;
}

.checkbox input {
  margin: 0;
}

.buttonGroup {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 2rem;
}

.submitButton,
.cancelButton {
  padding: 0.75rem 2rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.submitButton {
  background-color: #2196f3;
  color: white;
}

.submitButton:hover {
  background-color: #1976d2;
}

.cancelButton {
  background-color: #f5f5f5;
  color: #333;
}

.cancelButton:hover {
  background-color: #e0e0e0;
}
</file>

<file path="app/styles/globals.css">
/* Global styles */
html {
  scroll-behavior: smooth;
  scroll-snap-type: y mandatory;
}

html, body {
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0 L24 12 L12 24 L0 12 z" fill="none" stroke="black" stroke-width="2"/></svg>') 12 12, auto;
}

button, a, input {
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0 L24 12 L12 24 L0 12 z" fill="black" stroke="black" stroke-width="1"/></svg>') 12 12, pointer;
}
</file>

<file path="app/types/css.d.ts">
declare module '*.module.css' {
  const styles: {
    readonly [key: string]: string;
  };
  export default styles;
}
</file>

<file path="app/utils/constants.ts">
export const months = [
  '4月', '5月', '6月',        // 1行目
  '7月', '8月', '9月',        // 2行目
  '10月', '11月', '12月',     // 3行目
  '1月', '2月', '3月'         // 4行目
];
</file>

<file path="app/layout.tsx">
import React from 'react';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from './providers';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: '保育士イベントアイディア',
  description: '季節ごとの保育士のイベントアイディアを管理するアプリケーション',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}): JSX.Element {
  return (
    <html lang="ja">
      <body className={inter.className}>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="app/providers.tsx">
'use client';

import React, { ReactNode } from 'react';
import { AuthProvider } from './lib/auth';

interface ProvidersProps {
  children: ReactNode;
}

export function Providers({ children }: ProvidersProps): JSX.Element {
  return (
    <AuthProvider>
      {children}
    </AuthProvider>
  );
}
</file>

<file path="docs/supabase-setup.md">
# Supabase Database Setup Guide

This guide explains how to set up Supabase for the Childcare Event Ideas application.

## Initial Setup

1. Go to [Supabase](https://supabase.com) and create a new account or sign in.
2. Create a new project and give it a name (e.g., "childcare-event-ideas").
3. Take note of the URL and anon key (public API key) from the API settings page.
4. Add these values to your `.env.local` file:

```
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
```

## Database Schema

### Events Table

Create a new table called `events` with the following structure:

```sql
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  month INTEGER NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add a constraint to ensure month is between 1 and 12
ALTER TABLE events ADD CONSTRAINT month_range CHECK (month >= 1 AND month <= 12);
```

### Users Setup

For authentication, Supabase provides built-in user authentication. You can use the Authentication tab in the Supabase dashboard to manage users.

1. Go to Authentication → Settings and make sure Email auth is enabled.
2. To add a test user, go to Authentication → Users and click "Add User".
3. Enter an email and password for your test user.

## Row Level Security (RLS) Policies

Set up Row Level Security to ensure data privacy:

```sql
-- Enable RLS on the events table
ALTER TABLE events ENABLE ROW LEVEL SECURITY;

-- Create a policy that allows authenticated users to select events
CREATE POLICY "Allow users to view all events" ON events
  FOR SELECT USING (auth.role() = 'authenticated');

-- Create a policy that allows authenticated users to insert their own events
CREATE POLICY "Allow users to insert their own events" ON events
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Create a policy that allows authenticated users to update their own events
CREATE POLICY "Allow users to update their own events" ON events
  FOR UPDATE USING (auth.role() = 'authenticated');

-- Create a policy that allows authenticated users to delete their own events
CREATE POLICY "Allow users to delete their own events" ON events
  FOR DELETE USING (auth.role() = 'authenticated');
```

## Sample Data (Optional)

You can insert some sample data into the `events` table:

```sql
INSERT INTO events (month, title, description) VALUES
(1, '雪遊び', '園庭や公園で雪だるま作りや雪合戦を楽しみます。寒さ対策をしっかりと行い、温かい飲み物を用意しておくと良いでしょう。'),
(1, 'お正月あそび', '羽根つき、コマ回し、福笑いなど、日本の伝統的なお正月遊びを体験します。'),
(1, '冬の自然観察', '冬ならではの自然現象（霜、氷など）を観察し、季節の変化を学びます。'),
(4, '花見ピクニック', '近くの公園で桜の花見をしながらピクニックを楽しみます。春の花々についても学びます。'),
(4, '春の虫探し', '春に現れる虫（てんとう虫、蝶など）を探して観察します。虫かごや図鑑を用意しておくと良いでしょう。'),
(4, '植物の栽培開始', 'ひまわりやトマトなど、夏に向けての植物の種まきを行います。成長過程を観察する準備をします。'),
(7, '水遊び', 'プールや水鉄砲、シャボン玉などを使った水遊びを行います。熱中症対策を忘れずに。'),
(7, '七夕まつり', '七夕の由来を学び、笹に願い事を書いた短冊を飾ります。'),
(7, '夏の工作', '貝殻や砂などを使った夏らしい工作を楽しみます。'),
(10, '秋の自然物収集', 'どんぐり、落ち葉、木の実などを集めて工作や装飾に使います。'),
(10, 'ハロウィンパーティー', '仮装や飾り付け、ハロウィンにまつわるゲームを楽しみます。'),
(10, '焼き芋パーティー', '安全に配慮しながら、秋の味覚である焼き芋を楽しみます。'),
(12, 'クリスマス会', 'クリスマスの由来を学び、ツリーの飾り付けやプレゼント交換を行います。'),
(12, '年賀状づくり', '来年の干支について学び、手作りの年賀状を作成します。'),
(12, '冬の工作', '雪の結晶や冬をテーマにした工作を楽しみます。');
```

## Next Steps

1. Connect your frontend application to Supabase using the provided credentials.
2. Test the authentication flow and database operations.
3. Set up storage if you want to add image uploads later.
</file>

<file path="public/images/placeholder.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="300" height="200" viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg">
  <rect width="300" height="200" fill="#f5f5f5"/>
  <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="16" fill="#999" text-anchor="middle" dominant-baseline="middle">画像がありません</text>
</svg>
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "nursery-calendar2"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="utils/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

export const supabase = createClient(supabaseUrl, supabaseKey);
</file>

<file path=".cspell.json">
{
  "version": "0.2",
  "language": "en,ja",
  "words": [
    "supabase",
    "SUPABASE",
    "postgrest",
    "whatwg",
    "webidl",
    "streamsearch",
    "opencollective",
    "libvips",
    "linuxmusl",
    "msvc",
    "libc",
    "arrayish",
    "emnapi"
  ],
  "ignorePaths": [
    "node_modules/**",
    "package-lock.json",
    ".next/**",
    "public/**"
  ]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['images.unsplash.com', 'tlmaupowcuasyusfvswz.supabase.co'],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'tlmaupowcuasyusfvswz.supabase.co',
        port: '',
        pathname: '/storage/v1/object/public/**',
      },
    ],
    minimumCacheTTL: 60,
    formats: ['image/webp'],
  },
  // experimental: {
  //   serverActions: true, // Server Actionsは既にデフォルトで有効なので削除
  // },
};

module.exports = nextConfig;
</file>

<file path="setup.sql">
-- Create profiles table
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  name TEXT,
  role TEXT DEFAULT 'user',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Enable RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Allow public read access" ON profiles
  FOR SELECT USING (true);

CREATE POLICY "Allow users to update their own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Allow users to insert their own profile" ON profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

-- Create function to handle new user profiles
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, name)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'name');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user profiles
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- Create events table
CREATE TABLE events (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  title TEXT NOT NULL,
  date DATE NOT NULL,
  description TEXT NOT NULL,
  age_group TEXT NOT NULL,
  category TEXT NOT NULL,
  user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Enable Row Level Security (RLS)
ALTER TABLE events ENABLE ROW LEVEL SECURITY;

-- Create policy to allow users to read all events
CREATE POLICY "Allow public read access" ON events
  FOR SELECT USING (true);

-- Create policy to allow authenticated users to insert their own events
CREATE POLICY "Allow authenticated users to insert their own events" ON events
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Create policy to allow users to update their own events
CREATE POLICY "Allow users to update their own events" ON events
  FOR UPDATE USING (auth.uid() = user_id);

-- Create policy to allow users to delete their own events
CREATE POLICY "Allow users to delete their own events" ON events
  FOR DELETE USING (auth.uid() = user_id);

-- Create function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to automatically update updated_at timestamp
CREATE TRIGGER update_events_updated_at
  BEFORE UPDATE ON events
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="app/main/main.module.css">
.mainContainer {
  min-height: 100vh;
  background-color: #FFFFFF;
  padding: 40px 20px;
  position: relative;
  overflow: hidden;
  scroll-snap-align: start;
}

.mainContainer::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent 49.5%, #0000FF 49.5%, #0000FF 50.5%, transparent 50.5%),
              linear-gradient(0deg, transparent 49.5%, #0000FF 49.5%, #0000FF 50.5%, transparent 50.5%);
  background-size: 50px 50px;
  opacity: 0.05;
  z-index: 0;
  pointer-events: none;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 4px solid #000000;
  position: relative;
  z-index: 1;
}

.title {
  font-family: 'Courier New', monospace;
  font-size: 36px;
  font-weight: bold;
  margin: 0;
  position: relative;
  display: inline-block;
}

.title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 0;
  width: 100%;
  height: 4px;
  background-color: #FF0000;
}

.logoutButton {
  font-family: 'Courier New', monospace;
  font-weight: bold;
  padding: 10px 20px;
  background-color: #000000;
  color: #FFFFFF;
  border: none;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.logoutButton:hover {
  background-color: #FF0000;
  transform: rotate(-2deg);
}

.monthsGrid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 30px;
  position: relative;
  z-index: 1;
}

@media (max-width: 1200px) {
  .monthsGrid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 900px) {
  .monthsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 600px) {
  .monthsGrid {
    grid-template-columns: 1fr;
  }
}

.loadingContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
}

.loadingSpinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.errorContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
  text-align: center;
}

.errorContainer p {
  color: #e74c3c;
  margin-bottom: 1rem;
}

.errorContainer button {
  padding: 0.5rem 1rem;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.errorContainer button:hover {
  background-color: #2980b9;
}

/* Scroll snap container */
.scrollContainer {
  scroll-behavior: smooth;
  scroll-snap-type: y mandatory;
}

/* Custom cursor continues from login page */
.customCursor {
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0 L24 12 L12 24 L0 12 z" fill="none" stroke="black" stroke-width="2"/></svg>') 12 12, auto;
}

.clickableCursor {
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0 L24 12 L12 24 L0 12 z" fill="black" stroke="black" stroke-width="1"/></svg>') 12 12, pointer;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2015",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/components/AddEventForm.module.css">
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: center;
  align-items: center;
  backdrop-filter: blur(4px);
  z-index: 50;
  padding: 5vh 5vw; /* 上下左右5%の余白 */
}

.content {
  background-color: white;
  padding: 2.5rem;
  border-radius: 15px;
  width: 90vw; /* 幅を90vwに設定 */
  max-width: 1000px; /* 最大幅を1000pxに増やす */
  height: 90vh;
  animation: slideIn 0.3s ease-out;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  border: 2px solid #FFB5C5;
  position: relative;
  overflow-y: auto;
}

/* スクロールバーのスタイリング */
.content::-webkit-scrollbar {
  width: 8px;
}

.content::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb {
  background: #87CEEB;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb:hover {
  background: #6BB5D2;
}

@keyframes slideIn {
  from {
    transform: translateY(-10%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.title {
  font-size: 1.8rem;
  font-weight: 600;
  margin-bottom: 2rem;
  position: relative;
  display: inline-block;
  color: #6B9BD2;
  font-family: "M PLUS Rounded 1c", sans-serif;
  padding-bottom: 0.5rem;
}

.title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #FFB5C5, #87CEEB);
  border-radius: 2px;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
  margin-bottom: 1.5rem; /* 項目間の余白を追加 */
}

.formGroup label {
  font-weight: 600;
  color: #555;
  font-size: 1rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.formGroup input,
.formGroup textarea,
.formGroup select {
  width: 100%;
  padding: 0.8rem;
  border: 2px solid #E5E7EB;
  border-radius: 8px;
  outline: none;
  transition: all 0.3s ease;
  font-size: 1rem;
  background-color: #FAFAFA;
}

.formGroup input:focus,
.formGroup textarea:focus,
.formGroup select:focus {
  border-color: #87CEEB;
  background-color: white;
  box-shadow: 0 0 0 4px rgba(135, 206, 235, 0.1);
  transform: translateY(-2px);
}

.formGroup textarea {
  min-height: 120px; /* テキストエリアの最小の高さを設定 */
  resize: vertical;
}

.buttonGroup {
  display: flex;
  gap: 1rem;
  margin-top: 2rem;
  justify-content: flex-end;
  padding-top: 1rem;
  border-top: 1px solid #E5E7EB;
}

.submitButton,
.cancelButton {
  padding: 0.8rem 2.5rem;
  border-radius: 25px;
  font-weight: 600;
  font-size: 1rem;
  transition: all 0.3s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  letter-spacing: 0.05em;
}

.submitButton {
  background: linear-gradient(135deg, #FFB5C5 0%, #FFD4E5 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(255, 181, 197, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.submitButton:hover {
  background: linear-gradient(135deg, #FFD4E5 0%, #FFB5C5 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(255, 181, 197, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.submitButton:disabled {
  background: linear-gradient(135deg, #FFE5EE 0%, #FFE5EE 100%);
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
  opacity: 0.7;
}

.cancelButton {
  background: linear-gradient(135deg, #E8F4F8 0%, #D1EAF5 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(135, 206, 235, 0.2),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.cancelButton:hover {
  background: linear-gradient(135deg, #D1EAF5 0%, #E8F4F8 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(135, 206, 235, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.checkboxGroup, .radioGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 1rem;
  width: 100%; /* 幅を100%に設定 */
}

.checkbox, .radioLabel {
  flex: 0 0 calc(16.666% - 1rem);
  min-width: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  cursor: pointer;
  padding: 0.8rem 1.2rem;
  border: 2px solid #E5E7EB;
  border-radius: 12px;
  transition: all 0.3s ease;
  position: relative;
  background: white;
  text-align: center;
  user-select: none; /* テキスト選択を防ぐ */
}

.checkbox:hover, .radioLabel:hover {
  border-color: #FFB5C5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.checkbox input[type="checkbox"],
.radioInput {
  position: absolute;
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
  margin: 0;
  padding: 0;
  z-index: 1;
}

/* 年齢グループごとの色設定 */
.checkbox[data-age="0歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="0歳児"].selected {
  border-color: #FFB5C5;
  background: #FFF0F5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 181, 197, 0.2);
  animation: selectPop 0.3s ease-out;
}

.checkbox[data-age="1歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="1歳児"].selected {
  border-color: #FFD4B2;
  background: #FFF5EB;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 212, 178, 0.2);
  animation: selectPop 0.3s ease-out;
}

.checkbox[data-age="2歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="2歳児"].selected {
  border-color: #FFF3B8;
  background: #FFFBEB;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 243, 184, 0.2);
  animation: selectPop 0.3s ease-out;
}

.checkbox[data-age="3歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="3歳児"].selected {
  border-color: #B5E6B5;
  background: #F0FFF0;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(181, 230, 181, 0.2);
  animation: selectPop 0.3s ease-out;
}

.checkbox[data-age="4歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="4歳児"].selected {
  border-color: #A7D2FF;
  background: #F0F8FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(167, 210, 255, 0.2);
  animation: selectPop 0.3s ease-out;
}

.checkbox[data-age="5歳児"] input[type="checkbox"]:checked + span,
.checkbox[data-age="5歳児"].selected {
  border-color: #DCC2FF;
  background: #F8F0FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(220, 194, 255, 0.2);
  animation: selectPop 0.3s ease-out;
}

/* カテゴリーごとの色設定 */
.radioLabel[data-category="壁　面"] input[type="radio"]:checked + span,
.radioLabel[data-category="壁　面"].selected {
  border-color: #FFB5C5;
  background: #FFF0F5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 181, 197, 0.2);
  animation: selectPop 0.3s ease-out;
}

.radioLabel[data-category="制作物"] input[type="radio"]:checked + span,
.radioLabel[data-category="制作物"].selected {
  border-color: #A7D2FF;
  background: #F0F8FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(167, 210, 255, 0.2);
  animation: selectPop 0.3s ease-out;
}

.radioLabel[data-category="その他"] input[type="radio"]:checked + span,
.radioLabel[data-category="その他"].selected {
  border-color: #B5E6B5;
  background: #F0FFF0;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(181, 230, 181, 0.2);
  animation: selectPop 0.3s ease-out;
}

@keyframes selectPop {
  0% { transform: scale(0.95); }
  50% { transform: scale(1.02) translateY(-2px); }
  100% { transform: scale(1) translateY(-2px); }
}

.otherInput {
  margin-top: 0.5rem;
  width: 100%;
  padding: 0.8rem;
  border: 2px solid #E5E7EB;
  border-radius: 8px;
  transition: all 0.3s ease;
  display: none;
}

.otherInput.visible {
  display: block;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 画像・動画アップロード部分 */
.optionalSection {
  margin-top: 2rem;
  padding-top: 2rem;
  border-top: 2px dashed #E5E7EB;
}

.optionalTitle {
  font-size: 1.2rem;
  color: #666;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.optionalTitle::before {
  content: '📎';
}

.uploadArea {
  border: 2px dashed #E5E7EB;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.uploadArea:hover {
  border-color: #A7D2FF;
  background: #F0F8FF;
}

.uploadInput {
  display: none;
}

.previewArea {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.previewItem {
  position: relative;
  aspect-ratio: 1;
  border-radius: 8px;
  overflow: hidden;
}

.previewItem img,
.previewItem video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.removeButton {
  position: absolute;
  top: 5px;
  right: 5px;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.removeButton:hover {
  background: #FF9B9B;
  color: white;
}

.timeInputGroup {
  display: flex;
  align-items: center;
  gap: 1rem; /* 時間入力欄の間隔を広げる */
}

.timeInputGroup input {
  width: 100px; /* 時間入力欄の幅を広げる */
  text-align: center;
}

.timeInputGroup span {
  color: #666;
  font-size: 0.9rem;
}
</file>

<file path="app/components/AuthButton.tsx">
'use client';

import styles from './AuthButton.module.css';

export default function AuthButton() {
  const handleLogout = () => {
    try {
      // すべてのクッキーを削除
      document.cookie.split(";").forEach(c => {
        const key = c.trim().split("=")[0];
        if (key) {
          document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        }
      });
      
      // Supabase関連のローカルストレージをクリア
      localStorage.removeItem('supabase.auth.token');
      localStorage.removeItem('supabase.auth.expires_at');
      localStorage.removeItem('supabase.auth.refresh_token');
      
      // ページをリロード
      window.location.href = '/';
    } catch (error) {
      console.error('ログアウト処理エラー:', error);
      // エラーが発生しても強制的にホームページへ
      window.location.href = '/';
    }
  };

  return (
    <button 
      onClick={handleLogout} 
      className={styles.button}
    >
      ログアウト
    </button>
  );
}
</file>

<file path="app/components/AuthForm.tsx">
'use client';

import { useState } from 'react';
import { useAuth } from '../lib/auth';
import { useRouter } from 'next/navigation';
import styles from '../page.module.css';

export default function AuthForm() {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [loading, setLoading] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  const router = useRouter();
  const { signIn, signUp, error: authError } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setFormError(null);

    try {
      let result;
      if (isLogin) {
        result = await signIn(email, password);
      } else {
        result = await signUp(email, password, name);
      }

      if (result.error) {
        setFormError(result.error.message);
      } else {
        router.push('/main');
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '予期せぬエラーが発生しました';
      setFormError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const displayError = formError || (authError && authError.message);

  return (
    <div className={styles.authContainer}>
      <h2 className={styles.formTitle}>
        {isLogin ? 'ログイン' : '新規登録'}
      </h2>
      
      {displayError && (
        <div className={styles.errorMessage}>
          {displayError}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        {!isLogin && (
          <div className={styles.formGroup}>
            <label htmlFor="name" className={styles.label}>
              名前
            </label>
            <input
              id="name"
              type="text"
              required
              className={styles.input}
              value={name}
              onChange={(e) => setName(e.target.value)}
            />
          </div>
        )}

        <div className={styles.formGroup}>
          <label htmlFor="email" className={styles.label}>
            メールアドレス
          </label>
          <input
            id="email"
            type="email"
            required
            className={styles.input}
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="password" className={styles.label}>
            パスワード
          </label>
          <input
            id="password"
            type="password"
            required
            className={styles.input}
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>

        <button
          type="submit"
          disabled={loading}
          className={styles.button}
        >
          <span className={styles.buttonText}>
            {loading ? '処理中...' : isLogin ? 'ログイン' : '登録'}
          </span>
        </button>
      </form>

      <div
        className={styles.switchText}
        onClick={() => {
          setIsLogin(!isLogin);
          setFormError(null);
        }}
      >
        {isLogin ? '新規登録はこちら' : 'ログインはこちら'}
      </div>
    </div>
  );
}
</file>

<file path="app/auth/callback/route.ts">
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get('code');

  if (code) {
    const supabase = createRouteHandlerClient({ cookies });
    try {
      await supabase.auth.exchangeCodeForSession(code);
      return NextResponse.redirect(new URL('/main', request.url));
    } catch (error) {
      console.error('認証エラー:', error);
      return NextResponse.redirect(new URL('/?error=auth', request.url));
    }
  }

  return NextResponse.redirect(new URL('/', request.url));
}
</file>

<file path="app/components/EventOverlay.module.css">
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  backdrop-filter: blur(4px);
  padding: 5vh 5vw;
}

.content {
  background: white;
  padding: 2rem;
  border-radius: 20px;
  width: 90%;
  max-width: 90%;
  position: relative;
  max-height: 90vh;
  overflow-y: auto;
  border: 2px solid transparent;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

/* スクロールバーのスタイリング */
.content::-webkit-scrollbar {
  width: 8px;
}

.content::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb:hover {
  background: #999;
}

.closeButton {
  position: absolute;
  right: 1.5rem;
  top: 1.5rem;
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: #666;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.closeButton:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.header {
  margin-bottom: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.categoryLabel {
  font-size: 0.875rem;
  padding: 4px 12px;
  border-radius: 4px;
  width: fit-content;
  color: white;
}

.categoryLabel[data-category="壁　面"] {
  background-color: #A7D2FF;
}

.categoryLabel[data-category="制作物"] {
  background-color: #FFB5C5;
}

.categoryLabel[data-category="その他"] {
  background-color: #B5E6B5;
}

.title {
  font-size: 1.8rem;
  margin: 0;
  color: #333;
  font-weight: bold;
  line-height: 1.4;
}

.meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #eee;
}

.ageTags {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.ageTag {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 0.875rem;
}

/* 年齢タグの色分け */
.ageTag[data-age="0歳児"] {
  background-color: rgba(255, 182, 193, 0.2);
  color: #d4788f;
}

.ageTag[data-age="1歳児"] {
  background-color: rgba(255, 218, 185, 0.2);
  color: #d49a6a;
}

.ageTag[data-age="2歳児"] {
  background-color: rgba(176, 224, 230, 0.2);
  color: #6a9da3;
}

.ageTag[data-age="3歳児"] {
  background-color: rgba(144, 238, 144, 0.2);
  color: #5fa55f;
}

.ageTag[data-age="4歳児"] {
  background-color: rgba(230, 230, 250, 0.2);
  color: #8484b4;
}

.ageTag[data-age="5歳児"] {
  background-color: rgba(255, 239, 213, 0.2);
  color: #d4b48c;
}

.duration {
  color: #666;
  font-size: 0.875rem;
  background-color: #f5f5f5;
  padding: 4px 12px;
  border-radius: 12px;
}

.section {
  margin-bottom: 2rem;
  padding: 1.5rem;
  border-radius: 12px;
  transition: all 0.3s ease;
}

.sectionTitle {
  font-size: 1.2rem;
  color: #444;
  margin-bottom: 1rem;
  font-weight: bold;
  position: relative;
  padding-left: 1rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.sectionTitle::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 1em;
  border-radius: 2px;
}

.description, .materials, .objectives {
  color: #666;
  line-height: 1.8;
  font-size: 1rem;
}

.materials, .objectives {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.materials li, .objectives li {
  position: relative;
  padding-left: 1.5rem;
  margin-bottom: 0.5rem;
}

.materials li::before {
  content: '•';
  position: absolute;
  left: 0.5rem;
  color: #999;
}

.objectives li::before {
  content: '✓';
  position: absolute;
  left: 0.5rem;
  color: #999;
}

.eventFooter {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 1.5rem 0;
  padding: 1rem 0;
  border-top: 1px solid #eee;
}

.eventStats {
  display: flex;
  align-items: center;
  gap: 1rem;
  color: #666;
  font-size: 0.9rem;
}

.separator {
  color: #ccc;
  margin: 0 0.5rem;
}

.viewCount,
.dateInfo,
.authorInfo {
  display: flex;
  align-items: center;
}

.eventActions {
  display: flex;
  gap: 0.5rem;
  margin-left: 2rem;
}

.editButton,
.deleteButton {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 20px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
}

.editButton {
  background-color: #f0f0f0;
  color: #333;
}

.editButton:hover {
  background-color: #e0e0e0;
}

.deleteButton {
  background-color: #fff0f0;
  color: #ff4444;
}

.deleteButton:hover {
  background-color: #ffe0e0;
}

.deleteButton.deleting {
  opacity: 0.7;
  cursor: not-allowed;
}

/* 季節ごとのスタイル */
.spring {
  border-color: #ffb6c1;
}

.spring .section {
  background-color: rgba(255, 182, 193, 0.1);
}

.spring .section:hover {
  background-color: rgba(255, 182, 193, 0.15);
}

.spring .sectionTitle::before {
  background-color: #ffb6c1;
}

.spring .editButton {
  background-color: #ffb6c1;
  border: 1px solid #ffb6c1;
  color: white;
}

.spring .editButton:hover {
  background-color: white;
  color: #ffb6c1;
}

.spring .deleteButton {
  background-color: white;
  border: 1px solid #ffb6c1;
  color: #ffb6c1;
}

.spring .deleteButton:hover {
  background-color: #ffb6c1;
  color: white;
}

.summer {
  border-color: #87CEEB;
}

.summer .section {
  background-color: rgba(135, 206, 235, 0.05);
}

.summer .section:hover {
  background-color: rgba(135, 206, 235, 0.1);
}

.summer .sectionTitle::before {
  background-color: #87CEEB;
}

.summer .editButton {
  background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(135, 206, 235, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.summer .editButton:hover {
  background: linear-gradient(135deg, #B0E0E6 0%, #87CEEB 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(135, 206, 235, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.summer .deleteButton {
  background: linear-gradient(135deg, #75BCD6 0%, #87CEEB 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(117, 188, 214, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.summer .deleteButton:hover {
  background: linear-gradient(135deg, #5EABC8 0%, #75BCD6 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(117, 188, 214, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.3),
    inset 0 3px 6px rgba(255, 255, 255, 0.3);
}

.autumn {
  border-color: #FFB347;
}

.autumn .section {
  background-color: rgba(255, 179, 71, 0.05);
}

.autumn .section:hover {
  background-color: rgba(255, 179, 71, 0.1);
}

.autumn .sectionTitle::before {
  background-color: #FFB347;
}

.autumn .editButton {
  background: linear-gradient(135deg, #FFB347 0%, #FFD4B2 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(255, 179, 71, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.autumn .editButton:hover {
  background: linear-gradient(135deg, #FFD4B2 0%, #FFB347 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(255, 179, 71, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.autumn .deleteButton {
  background: linear-gradient(135deg, #FF9F2E 0%, #FFB347 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(255, 159, 46, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.autumn .deleteButton:hover {
  background: linear-gradient(135deg, #FF8C00 0%, #FF9F2E 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(255, 159, 46, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.3),
    inset 0 3px 6px rgba(255, 255, 255, 0.3);
}

.winter {
  border-color: #B0E0E6;
}

.winter .section {
  background-color: rgba(176, 224, 230, 0.05);
}

.winter .section:hover {
  background-color: rgba(176, 224, 230, 0.1);
}

.winter .sectionTitle::before {
  background-color: #B0E0E6;
}

.winter .editButton {
  background: linear-gradient(135deg, #B0E0E6 0%, #D1EAF5 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(176, 224, 230, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.winter .editButton:hover {
  background: linear-gradient(135deg, #D1EAF5 0%, #B0E0E6 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(176, 224, 230, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.winter .deleteButton {
  background: linear-gradient(135deg, #9CD1D8 0%, #B0E0E6 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(156, 209, 216, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.winter .deleteButton:hover {
  background: linear-gradient(135deg, #85C2CA 0%, #9CD1D8 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(156, 209, 216, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.3),
    inset 0 3px 6px rgba(255, 255, 255, 0.3);
}

/* メディアセクションのスタイル */
.mediaSection {
  margin-bottom: 2rem;
}

.mediaGallery {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  justify-content: flex-start;
}

.mediaItem {
  width: 100%;
  max-width: 500px;
  margin-bottom: 1rem;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.mediaImage {
  width: 100%;
  height: auto;
  object-fit: contain;
  max-height: 300px;
  border-radius: 8px;
  display: block;
}

.mediaVideo {
  width: 100%;
  max-height: 300px;
  border-radius: 8px;
}
</file>

<file path="app/main/page.module.css">
.container {
  width: 100%;
  min-height: 100vh;
  padding: 2rem;
  background: linear-gradient(to bottom, #ffffff, #f8f8f8);
  position: relative;
}

.headerWrapper {
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

.header {
  margin-bottom: 2rem;
  padding: 1rem 0;
  border-bottom: 3px solid #ff9b9b;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.headerButtons {
  display: flex;
  gap: 1rem;
  align-items: center;
}

.title {
  font-size: 2.5rem;
  font-weight: bold;
  color: #FF6B88;
  position: relative;
  display: inline-block;
  padding-bottom: 0.5rem;
}

.title::after {
  content: '';
  position: absolute;
  bottom: -3px;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #FFB5C5, #FFB347);
}

.viewAllLink {
  padding: 0.75rem 1.5rem;
  background: linear-gradient(135deg, #A7D2FF, #75bcd6);
  color: white;
  border-radius: 8px;
  text-decoration: none;
  font-weight: bold;
  font-size: 1rem;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(167, 210, 255, 0.2);
}

.viewAllLink:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(167, 210, 255, 0.3);
}

.viewAllLink:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(167, 210, 255, 0.2);
}

.logoutButton {
  padding: 0.75rem 1.5rem;
  background-color: #FF8BA7;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: bold;
  font-size: 1rem;
  box-shadow: 0 2px 4px rgba(255, 139, 167, 0.2);
}

.logoutButton:hover {
  background-color: #FF6B88;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(255, 139, 167, 0.3);
}

.logoutButton:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(255, 139, 167, 0.2);
}

.descriptionContainer {
  max-width: 1400px;
  margin: 0 auto 3rem;
  padding: 2rem;
  background-color: white;
  border-radius: 15px;
  position: relative;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
  border: 2px dashed #B5E6B5;
}

/* 装飾的な要素を追加 */
.descriptionContainer::before,
.descriptionContainer::after {
  content: '';
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  opacity: 0.3;
}

.descriptionContainer::before {
  top: -15px;
  left: -15px;
  background: #FFD700; /* 黄色 */
}

.descriptionContainer::after {
  bottom: -15px;
  right: -15px;
  background: #98D8BF; /* 黄緑と黄色に調和する薄い青緑 */
}

.description {
  font-size: 1.1rem;
  line-height: 1.8;
  color: #666;
  text-align: center;
  margin: 0;
  padding: 0;
  background: none;
  border: none;
  box-shadow: none;
}

/* 装飾的な要素を削除 */
.description::before,
.description::after {
  content: none;
}

.description:last-child {
  margin-bottom: 0;
}

.eventsContainer {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 2rem;
  margin: 2rem auto;
  width: 100%;
  max-width: 1400px;
  padding: 0 2rem;
}

.monthContainer {
  background-color: #FFFFFF;
  border-radius: 20px;
  padding: 20px;
  transition: all 0.3s ease;
  height: 100%;
  display: flex;
  flex-direction: column;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.monthContainer:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.monthTitle {
  font-size: 24px;
  font-weight: bold;
  color: var(--text-primary);
  margin-bottom: 20px;
  text-align: center;
  padding-bottom: 10px;
}

.eventList {
  flex-grow: 1;
  min-height: 150px;
  margin-bottom: 1rem;
}

.eventItem {
  padding: 15px;
  margin-bottom: 15px;
  background-color: #FFFFFF;
  border: 2px solid var(--primary-green);
  border-radius: 8px;
  transition: all 0.3s ease;
}

.eventItem:hover {
  transform: translateX(5px);
  border-color: var(--accent-salmon);
}

.eventItem:last-child {
  margin-bottom: 0;
}

.eventTitle {
  font-size: 18px;
  font-weight: bold;
  color: var(--text-primary);
  margin-bottom: 10px;
}

.eventDetails {
  font-size: 14px;
  color: var(--text-secondary);
}

.noEvents {
  text-align: center;
  color: #666;
  padding: 2rem 0;
}

.addButton {
  width: 80%;
  padding: 12px;
  color: #FFFFFF;
  border: none;
  border-radius: 25px;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: auto auto 0;
  display: block;
}

/* 季節ごとの色分け */
.spring {
  border: 2px solid #ff9a9e;
  background-color: #fff5f5;
  box-shadow: 0 4px 6px rgba(255, 154, 158, 0.1);
}

.spring .addButton {
  background: linear-gradient(135deg, #ff9a9e, #fad0c4);
}

.spring .addButton:hover {
  background: linear-gradient(135deg, #ff8a8e, #f9c0b4);
  transform: translateY(-2px);
}

.summer {
  border: 2px solid #86efac;
  background-color: #f0fff4;
  box-shadow: 0 4px 6px rgba(134, 239, 172, 0.1);
}

.summer .addButton {
  background: linear-gradient(135deg, #86efac, #4ade80);
}

.summer .addButton:hover {
  background: linear-gradient(135deg, #76df9c, #3ace70);
  transform: translateY(-2px);
}

.autumn {
  border: 2px solid #fb923c;
  background-color: #fff7ed;
  box-shadow: 0 4px 6px rgba(251, 146, 60, 0.1);
}

.autumn .addButton {
  background: linear-gradient(135deg, #fb923c, #fdba74);
}

.autumn .addButton:hover {
  background: linear-gradient(135deg, #eb822c, #edb064);
  transform: translateY(-2px);
}

.winter {
  border: 2px solid #a78bfa;
  background-color: #f5f3ff;
  box-shadow: 0 4px 6px rgba(167, 139, 250, 0.1);
}

.winter .addButton {
  background: linear-gradient(135deg, #a78bfa, #c4b5fd);
}

.winter .addButton:hover {
  background: linear-gradient(135deg, #977bea, #b4a5ed);
  transform: translateY(-2px);
}

/* モーダル関連のスタイル */
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal {
  background-color: white;
  padding: 2rem;
  border-radius: 15px;
  max-width: 600px;
  width: 90%;
  position: relative;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

/* ローディング状態のスタイル */
.loadingContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #ffffff;
  padding: 2rem;
}

.loadingSpinner {
  width: 60px;
  height: 60px;
  border: 6px solid #FFE4E8;
  border-top: 6px solid #FF8BA7;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1.5rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loadingContainer p {
  color: #666;
  font-size: 1.2rem;
  font-weight: 500;
}

/* エラー状態のスタイル */
.errorContainer {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 2rem;
  border-radius: 15px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  text-align: center;
  max-width: 90%;
  width: 400px;
  z-index: 1000;
}

.errorMessage {
  color: #ff6b6b;
  font-size: 1.1rem;
  margin-bottom: 1.5rem;
  line-height: 1.5;
}

.retryButton {
  background: linear-gradient(135deg, #FFB5C5 0%, #FFD4E5 100%);
  color: #444;
  padding: 0.8rem 2.5rem;
  border: none;
  border-radius: 25px;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 
    0 4px 15px rgba(255, 181, 197, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.retryButton:hover {
  background: linear-gradient(135deg, #FFD4E5 0%, #FFB5C5 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(255, 181, 197, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

/* タブレット向け */
@media (max-width: 1024px) {
  .eventsContainer {
    grid-template-columns: repeat(2, 1fr);
    grid-template-rows: repeat(6, 1fr);
  }
  
  .container {
    padding: 1.5rem;
  }
}

/* スマートフォン向け */
@media (max-width: 768px) {
  .eventsContainer {
    grid-template-columns: 1fr;
    grid-template-rows: repeat(12, 1fr);
    gap: 1rem;
  }
  
  .container {
    padding: 1rem;
  }
  
  .headerWrapper,
  .descriptionContainer {
    max-width: 100%;
  }
}

/* 装飾的な要素 */
.decorationDot {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  z-index: -1;
}

.decorationDot:nth-child(1) {
  top: 20px;
  left: 20px;
  background-color: var(--primary-yellow);
  opacity: 0.3;
}

.decorationDot:nth-child(2) {
  top: 40px;
  right: 40px;
  background-color: var(--primary-pink);
  opacity: 0.3;
}

.decorationDot:nth-child(3) {
  bottom: 30px;
  left: 50%;
  background-color: var(--primary-green);
  opacity: 0.3;
}

.monthCard {
  background: white;
  border-radius: 20px;
  padding: 1.5rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  height: 100%;
  display: flex;
  flex-direction: column;
  border: 2px solid transparent;
}

.monthCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.monthHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #FFB5C5;
}

.monthTitle {
  font-size: 1.8rem;
  font-weight: bold;
  color: #333;
}

.addButton {
  width: 80%;
  padding: 12px;
  color: white;
  border: none;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
  margin: auto auto 0;
  display: block;
}

.addButton:hover {
  transform: translateY(-2px);
}

.eventsList {
  flex-grow: 1;
  margin-bottom: 1rem;
}

.noEvents {
  text-align: center;
  color: #666;
  font-style: italic;
  padding: 1rem 0;
}

.viewAllButton {
  display: block;
  width: fit-content;
  margin: 2rem auto;
  padding: 1rem 2rem;
  background: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
  border-radius: 25px;
  color: white;
  text-decoration: none;
  font-weight: bold;
  text-align: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s, box-shadow 0.2s;
}

.viewAllButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.popularSection {
  margin: 2rem 0 3rem;
  padding: 2rem;
  background: white;
  border-radius: 15px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
  border: 2px dashed #FFB5C5;
}

.sectionTitle {
  font-size: 1.8rem;
  color: #FF6B88;
  margin-bottom: 1.5rem;
  text-align: center;
  position: relative;
  display: inline-block;
  padding-bottom: 0.5rem;
}

.sectionTitle::after {
  content: '';
  position: absolute;
  bottom: -3px;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #FFB5C5, #FFB347);
}

.popularEvents {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1.5rem;
}

.popularEventCard {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.popularEventCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.popularEventHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.popularEventMonth {
  font-size: 1.1rem;
  font-weight: bold;
  color: #666;
}

.popularEventViews {
  font-size: 0.9rem;
  color: #666;
  display: flex;
  align-items: center;
  gap: 0.3rem;
}

.popularEventTitle {
  font-size: 1.2rem;
  color: #333;
  margin: 0.5rem 0;
  line-height: 1.4;
}

.popularEventMeta {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin-top: 1rem;
  gap: 0.5rem;
}

.popularEventAges {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.popularEventAge {
  padding: 0.3rem 0.6rem;
  border-radius: 12px;
  font-size: 0.8rem;
  background-color: #f3f4f6;
  color: #666;
}

.monthGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 2rem;
  margin-top: 2rem;
  width: 100%;
  max-width: 1400px;
  margin: 2rem auto;
}

@media (max-width: 1024px) {
  .monthGrid {
    grid-template-columns: repeat(2, 1fr);
    grid-template-rows: repeat(6, 1fr);
  }
}

@media (max-width: 1440px) {
  .headerWrapper,
  .descriptionContainer {
    max-width: calc(100% - 4rem);
  }
}

/* フィードバックメッセージのスタイル */
.feedbackMessage {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 1rem 2rem;
  border-radius: 8px;
  color: white;
  font-weight: 500;
  z-index: 1000;
  animation: slideIn 0.3s ease-out forwards;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.success {
  background: linear-gradient(135deg, #4ade80, #22c55e);
}

.error {
  background: linear-gradient(135deg, #f87171, #ef4444);
}

.warning {
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
}

/* アニメーション効果 */
@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.newEventAnimation {
  animation: popIn 0.5s ease-out forwards;
}

@keyframes popIn {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}
</file>

<file path="app/types/event.ts">
/**
 * 時間の型定義
 */
export interface Duration {
  start: string;
  end: string;
}

/**
 * メディアファイルの型定義
 */
export interface MediaFile {
  type: 'image' | 'video';
  url: string;
}

/**
 * プロフィールの型定義
 */
export interface Profile {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
}

/**
 * イベントのカテゴリー
 */
export type Category = '壁　面' | '制作物' | 'その他';

/**
 * 対象年齢グループ
 */
export type AgeGroup = '0歳児' | '1歳児' | '2歳児' | '3歳児' | '4歳児' | '5歳児';

/**
 * イベントの基本データ型
 */
export interface EventBase {
  title: string;
  description: string;
  category: Category;
  month: string;
  date: string;
  duration: Duration | string | null | undefined;
  materials: string[];
  objectives: string[];
  age_groups: AgeGroup[];
  media_files: MediaFile[];
}

/**
 * イベントの型定義
 */
export interface Event extends EventBase {
  id: string;
  views: number;
  created_at: string;
  updated_at: string;
  user_id: string;
  isOwner: boolean;
  profiles: Profile;
}

/**
 * イベントフォームデータの型定義
 */
export interface EventFormData extends EventBase {
  id?: string;
}

/**
 * ローカルイベントフォームデータの型定義
 */
export interface LocalEventFormData extends Omit<EventFormData, 'media_files' | 'duration' | 'date'> {
  media_files: File[];
  duration: string;
  date?: string;
}
</file>

<file path="middleware.ts">
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value,
            ...options,
          });
        },
        remove(name: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value: '',
            ...options,
          });
        },
      },
    }
  );

  try {
    const { data: { session } } = await supabase.auth.getSession();
    const path = request.nextUrl.pathname;

    // 特殊なログアウトパスの処理
    if (path === '/_logout') {
      const redirectUrl = new URL('/', request.url);
      response = NextResponse.redirect(redirectUrl);
      
      // クッキーを削除
      const cookieNames = ['sb-access-token', 'sb-refresh-token'];
      cookieNames.forEach(name => {
        response.cookies.set({
          name,
          value: '',
          maxAge: 0,
          path: '/',
        });
      });
      
      return response;
    }

    // 通常の認証ルーティング
    if (!session && path.startsWith('/main')) {
      const redirectUrl = new URL('/', request.url);
      return NextResponse.redirect(redirectUrl);
    }

    if (session && path === '/') {
      const redirectUrl = new URL('/main', request.url);
      return NextResponse.redirect(redirectUrl);
    }

    return response;
  } catch (error) {
    console.error('認証チェックに失敗しました:', error);
    if (request.nextUrl.pathname.startsWith('/main')) {
      const redirectUrl = new URL('/', request.url);
      return NextResponse.redirect(redirectUrl);
    }
    return response;
  }
}

export const config = {
  matcher: ['/', '/main/:path*', '/auth/:path*', '/_logout'],
};
</file>

<file path="app/components/EditEventForm.module.css">
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: center;
  align-items: center;
  backdrop-filter: blur(4px);
  z-index: 50;
  padding: 5vh 5vw;
}

.content {
  background-color: white;
  padding: 2.5rem;
  border-radius: 15px;
  width: 100%;
  height: 100%;
  animation: slideIn 0.3s ease-out;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  border: 2px solid #FFB5C5;
  position: relative;
  overflow-y: auto;
}

/* スクロールバーのスタイリング */
.content::-webkit-scrollbar {
  width: 8px;
}

.content::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb {
  background: #87CEEB;
  border-radius: 4px;
}

.content::-webkit-scrollbar-thumb:hover {
  background: #6BB5D2;
}

@keyframes slideIn {
  from {
    transform: translateY(-10%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.title {
  font-size: 1.8rem;
  font-weight: 600;
  margin-bottom: 2rem;
  position: relative;
  display: inline-block;
  color: #6B9BD2;
  font-family: "M PLUS Rounded 1c", sans-serif;
  padding-bottom: 0.5rem;
}

.title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #FFB5C5, #87CEEB);
  border-radius: 2px;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
  width: 100%;
}

.formGroup label {
  font-weight: 600;
  color: #555;
  font-size: 1rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.formGroup input,
.formGroup textarea,
.formGroup select {
  padding: 0.8rem;
  border: 2px solid #E5E7EB;
  border-radius: 8px;
  outline: none;
  transition: all 0.3s ease;
  font-size: 1rem;
  background-color: #FAFAFA;
}

.formGroup input:focus,
.formGroup textarea:focus,
.formGroup select:focus {
  border-color: #87CEEB;
  background-color: white;
  box-shadow: 0 0 0 4px rgba(135, 206, 235, 0.1);
  transform: translateY(-2px);
}

.formGroup textarea {
  min-height: 100px;
  resize: vertical;
}

.fullWidth {
  width: 100%;
  box-sizing: border-box;
}

.buttons {
  display: flex;
  gap: 1rem;
  margin-top: 2rem;
  justify-content: flex-end;
}

.submitButton,
.cancelButton {
  padding: 0.8rem 2.5rem;
  border-radius: 25px;
  font-weight: 600;
  font-size: 1rem;
  transition: all 0.3s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  letter-spacing: 0.05em;
}

.submitButton {
  background: linear-gradient(135deg, #FFB5C5 0%, #FFD4E5 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(255, 181, 197, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.submitButton:hover {
  background: linear-gradient(135deg, #FFD4E5 0%, #FFB5C5 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(255, 181, 197, 0.4),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.submitButton:disabled {
  background: linear-gradient(135deg, #FFE5EE 0%, #FFE5EE 100%);
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
  opacity: 0.7;
}

.cancelButton {
  background: linear-gradient(135deg, #E8F4F8 0%, #D1EAF5 100%);
  color: #444;
  box-shadow: 
    0 4px 15px rgba(135, 206, 235, 0.2),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.cancelButton:hover {
  background: linear-gradient(135deg, #D1EAF5 0%, #E8F4F8 100%);
  transform: translateY(-2px);
  box-shadow: 
    0 6px 20px rgba(135, 206, 235, 0.3),
    inset 0 -3px 6px rgba(255, 255, 255, 0.5),
    inset 0 3px 6px rgba(255, 255, 255, 0.5);
}

.checkboxGroup,
.radioGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-top: 0.5rem;
}

.checkbox,
.radioLabel {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.8rem 1.2rem;
  border: 2px solid #E5E7EB;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  background: white;
}

.checkbox:hover,
.radioLabel:hover {
  border-color: #FFB5C5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.checkbox input[type="checkbox"],
.radioLabel input[type="radio"] {
  display: none;
}

/* 年齢グループの選択状態 */
.checkbox[data-age="0歳児"].selected {
  border-color: #FFB5C5;
  background: #FFF0F5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 181, 197, 0.2);
}

.checkbox[data-age="1歳児"].selected {
  border-color: #FFD4B2;
  background: #FFF5EB;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 212, 178, 0.2);
}

.checkbox[data-age="2歳児"].selected {
  border-color: #FFF3B8;
  background: #FFFBEB;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 243, 184, 0.2);
}

.checkbox[data-age="3歳児"].selected {
  border-color: #B5E6B5;
  background: #F0FFF0;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(181, 230, 181, 0.2);
}

.checkbox[data-age="4歳児"].selected {
  border-color: #A7D2FF;
  background: #F0F8FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(167, 210, 255, 0.2);
}

.checkbox[data-age="5歳児"].selected {
  border-color: #DCC2FF;
  background: #F8F0FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(220, 194, 255, 0.2);
}

/* カテゴリーの選択状態 */
.radioLabel[data-category="壁　面"].selected {
  border-color: #FFB5C5;
  background: #FFF0F5;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 181, 197, 0.2);
}

.radioLabel[data-category="制作物"].selected {
  border-color: #A7D2FF;
  background: #F0F8FF;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(167, 210, 255, 0.2);
}

.radioLabel[data-category="その他"].selected {
  border-color: #B5E6B5;
  background: #F0FFF0;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(181, 230, 181, 0.2);
}

@keyframes selectPop {
  0% { transform: scale(0.95); }
  50% { transform: scale(1.02) translateY(-2px); }
  100% { transform: scale(1) translateY(-2px); }
}

.checkbox.selected,
.radioLabel.selected {
  animation: selectPop 0.3s ease-out;
}

.timeInputGroup {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.timeInputGroup input {
  width: 80px;
  text-align: center;
}

.timeInputGroup span {
  color: #666;
  font-size: 0.9rem;
}

/* 画像・動画アップロード部分 */
.optionalSection {
  margin-top: 2rem;
  padding-top: 2rem;
  border-top: 2px dashed #E5E7EB;
}

.optionalTitle {
  font-size: 1.2rem;
  color: #666;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.optionalTitle::before {
  content: '📎';
}

.uploadArea {
  border: 2px dashed #E5E7EB;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #FAFAFA;
}

.uploadArea:hover {
  border-color: #A7D2FF;
  background: #F0F8FF;
}

.uploadInput {
  display: none;
}

.previewArea {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.previewItem {
  position: relative;
  aspect-ratio: 1;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.previewItem img,
.previewItem video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.removeButton {
  position: absolute;
  top: 5px;
  right: 5px;
  background: rgba(255, 255, 255, 0.9);
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 1rem;
  color: #666;
}

.removeButton:hover {
  background: #FF9B9B;
  color: white;
}

/* ボタングループの配置を右下に固定 */
.buttonGroup {
  position: sticky;
  bottom: 0;
  background: white;
  padding: 1rem 0;
  margin-top: 2rem;
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  border-top: 1px solid #E5E7EB;
}
</file>

<file path="app/events/page.module.css">
.container {
  width: 100%;
  min-height: 100vh;
  padding: 2rem;
  background: linear-gradient(to bottom, #ffffff, #f8f8f8);
}

.contentWrapper {
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

.container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(circle at 20% 20%, rgba(96, 165, 250, 0.1) 0%, transparent 20%),
    radial-gradient(circle at 80% 80%, rgba(147, 197, 253, 0.1) 0%, transparent 20%),
    radial-gradient(circle at 50% 50%, rgba(191, 219, 254, 0.1) 0%, transparent 15%);
  opacity: 0.3;
  z-index: 1;
}

/* 春（3-5月） */
.springContainer {
  border: 1px solid #ff9a9e;
  border-radius: 16px;
  background-color: #fff5f5;
}

.springButton {
  background: linear-gradient(135deg, #ff9a9e, #fad0c4);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}

/* 夏（6-8月） */
.summerContainer {
  border: 1px solid #60a5fa;
  border-radius: 16px;
  background-color: #f0f7ff;
}

.summerButton {
  background: linear-gradient(135deg, #A7D2FF, #75bcd6);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}

/* 秋（9-11月） */
.autumnContainer {
  border: 1px solid #fb923c;
  border-radius: 16px;
  background-color: #fff7ed;
}

.autumnButton {
  background: linear-gradient(135deg, #fb923c, #fdba74);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}

/* 冬（12-2月） */
.winterContainer {
  border: 1px solid #93c5fd;
  border-radius: 16px;
  background-color: #f8fafc;
}

.winterButton {
  background: linear-gradient(135deg, #93c5fd, #bfdbfe);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  padding: 1rem 0;
  border-bottom: 3px solid #60a5fa;
  position: relative;
}

.header::after {
  content: none;
}

.pageTitle {
  font-size: 2.5rem;
  font-weight: bold;
  color: #60a5fa;
  margin: 0;
  font-family: "M PLUS Rounded 1c", sans-serif;
  position: relative;
  display: inline-block;
  padding-bottom: 0.5rem;
}

.pageTitle::before,
.pageTitle::after {
  content: none;
}

.pageTitle::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: #B5E6B5;
}

.headerButtons {
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-direction: row-reverse;
}

.backButton {
  padding: 0.75rem 1.5rem;
  background: #A7D2FF;
  color: white;
  border: none;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 500;
  font-size: 1rem;
  transition: all 0.3s ease;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  position: relative;
}

.backButton:hover {
  opacity: 0.8;
  transform: translateY(-1px);
}

.logoutButton {
  padding: 0.75rem 1.5rem;
  background-color: #FF8BA7;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
  font-size: 1rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  position: relative;
}

.logoutButton:hover {
  opacity: 0.8;
  transform: translateY(-1px);
}

.searchSection {
  background: #ffffff;
  padding: 2rem;
  border-radius: 15px;
  margin: 2rem 0;
  border: 2px dotted #B5B0E2;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
  position: relative;
}

.searchSection::before {
  content: '';
  position: absolute;
  top: -12px;
  left: -12px;
  width: 30px;
  height: 30px;
  background: #FFB88C;
  border-radius: 50%;
  opacity: 0.3;
}

.searchSection::after {
  content: '';
  position: absolute;
  bottom: -12px;
  right: -12px;
  width: 30px;
  height: 30px;
  background: #B5B0E2;
  border-radius: 50%;
  opacity: 0.3;
}

.searchBar {
  display: flex;
  gap: 1rem;
  align-items: center;
  margin-bottom: 1rem;
}

.searchInput {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 1px solid #E2E8F0;
  border-radius: 8px;
  font-size: 1rem;
  color: #666;
  transition: all 0.2s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  background: white;
  z-index: 10;
  position: relative;
}

.searchInput:focus {
  outline: none;
  border-color: #A7D2FF;
  box-shadow: 0 0 0 3px rgba(167, 210, 255, 0.2);
}

.searchButtons {
  display: flex;
  gap: 0.5rem;
}

.searchButton {
  background: #A7D2FF;
  color: white;
  min-width: 80px;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.2s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  font-weight: 500;
  white-space: nowrap;
  z-index: 10;
  position: relative;
}

.searchButton:hover {
  opacity: 0.8;
  transform: translateY(-1px);
}

.advancedSearchButton {
  background: white;
  color: #666;
  border: 1px solid #E2E8F0;
  min-width: 100px;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.2s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  font-weight: 500;
  white-space: nowrap;
  z-index: 10;
  position: relative;
}

.advancedSearchButton:hover {
  background: #F8FAFC;
  transform: translateY(-1px);
}

.sortContainer {
  display: flex;
  gap: 1rem;
  padding-top: 1rem;
  border-top: 2px dotted #E2E8F0;
  position: relative;
  z-index: 10;
}

.sortButton {
  padding: 0.5rem 1rem;
  background: white;
  border: 1px solid #E2E8F0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.9rem;
  color: #666;
  font-family: "M PLUS Rounded 1c", sans-serif;
  position: relative;
  z-index: 10;
}

.sortButton:hover {
  background: #F8FAFC;
  transform: translateY(-1px);
}

.sortButton.active {
  background: #A7D2FF;
  color: white;
  border-color: #A7D2FF;
}

.eventsGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
  margin-top: 2rem;
  position: relative;
  z-index: 2;
}

/* 月ごとのカラー設定 */
.month1 .eventCard { border-color: #FF6B6B; }
.month2 .eventCard { border-color: #4A90E2; }
.month3 .eventCard { border-color: #FF9FB2; }
.month4 .eventCard { border-color: #7ED321; }
.month5 .eventCard { border-color: #4FD1C5; }
.month6 .eventCard { border-color: #9B6DFF; }
.month7 .eventCard { border-color: #54C7FC; }
.month8 .eventCard { border-color: #FFB347; }
.month9 .eventCard { border-color: #4CAF50; }
.month10 .eventCard { border-color: #FFB74D; }
.month11 .eventCard { border-color: #FF7043; }
.month12 .eventCard { border-color: #5C6BC0; }

.eventCard {
  background: white;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease;
  cursor: pointer;
  height: 480px;
  display: flex;
  flex-direction: column;
  border: 2px solid;
}

/* 月ごとの背景グラデーション */
.month1 .eventCard { background: linear-gradient(135deg, #fff, #fff5f5); }
.month2 .eventCard { background: linear-gradient(135deg, #fff, #f5f8ff); }
.month3 .eventCard { background: linear-gradient(135deg, #fff, #fff5f7); }
.month4 .eventCard { background: linear-gradient(135deg, #fff, #f7fff0); }
.month5 .eventCard { background: linear-gradient(135deg, #fff, #f0fffd); }
.month6 .eventCard { background: linear-gradient(135deg, #fff, #f8f5ff); }
.month7 .eventCard { background: linear-gradient(135deg, #fff, #f0faff); }
.month8 .eventCard { background: linear-gradient(135deg, #fff, #fff7f0); }
.month9 .eventCard { background: linear-gradient(135deg, #fff, #f0fff1); }
.month10 .eventCard { background: linear-gradient(135deg, #fff, #fff8f0); }
.month11 .eventCard { background: linear-gradient(135deg, #fff, #fff5f0); }
.month12 .eventCard { background: linear-gradient(135deg, #fff, #f5f6ff); }

.eventCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.eventImageContainer {
  width: 100%;
  height: 200px;
  margin-bottom: 16px;
  border-radius: 8px;
  overflow: hidden;
}

.eventImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.noImage {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  color: #999;
  font-size: 1.2em;
}

.eventContent {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.eventHeader {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.eventTitle {
  margin: 0;
  font-size: 1.2em;
  font-weight: bold;
  color: #333;
}

.eventDescription {
  margin: 8px 0;
  font-size: 0.9em;
  color: #666;
  line-height: 1.5;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.ageGroups {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 8px 0;
}

.ageGroup {
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  color: white;
}

.eventFooter {
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 8px;
}

.month {
  font-weight: bold;
  color: inherit;
}

/* 月の色設定 */
.month1 .month { color: #FF6B6B; }
.month2 .month { color: #4A90E2; }
.month3 .month { color: #FF9FB2; }
.month4 .month { color: #7ED321; }
.month5 .month { color: #4FD1C5; }
.month6 .month { color: #9B6DFF; }
.month7 .month { color: #54C7FC; }
.month8 .month { color: #FFB347; }
.month9 .month { color: #4CAF50; }
.month10 .month { color: #FFB74D; }
.month11 .month { color: #FF7043; }
.month12 .month { color: #5C6BC0; }

.duration {
  color: #666;
  font-size: 0.9em;
}

.category {
  padding: 4px 12px;
  border-radius: 20px;
  color: white;
  font-size: 0.9rem;
  font-weight: 500;
  white-space: nowrap;
}

.categoryWall {
  background-color: #A7D2FF;
}

.categoryArt {
  background-color: #FFB5C5;
}

.categoryOther {
  background-color: #B5E6B5;
}

.date {
  font-size: 1rem;
  color: #666;
  font-family: "M PLUS Rounded 1c", sans-serif;
  background: rgba(96, 165, 250, 0.1);
  padding: 0.4rem 0.8rem;
  border-radius: 20px;
}

.title {
  font-size: 1.2rem;
  color: #444;
  margin: 0.5rem 0;
  font-weight: 600;
  line-height: 1.4;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.description {
  color: #666;
  font-size: 0.95rem;
  line-height: 1.6;
  margin: 0;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.details {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8rem;
  margin-top: 1rem;
}

/* 年齢タグの色分け */
.age0 {
  background-color: rgba(255, 182, 193, 0.15);
  color: #d4788f;
}

.age1 {
  background-color: rgba(255, 218, 185, 0.15);
  color: #d49a6a;
}

.age2 {
  background-color: rgba(176, 224, 230, 0.15);
  color: #6a9da3;
}

.age3 {
  background-color: rgba(144, 238, 144, 0.15);
  color: #5fa55f;
}

.age4 {
  background-color: rgba(230, 230, 250, 0.15);
  color: #8484b4;
}

.age5 {
  background-color: rgba(255, 239, 213, 0.15);
  color: #d4b48c;
}

.duration {
  font-size: 0.9rem;
  color: #666;
  background-color: rgba(96, 165, 250, 0.1);
  padding: 0.4rem 0.8rem;
  border-radius: 15px;
  font-family: "M PLUS Rounded 1c", sans-serif;
  white-space: nowrap;
}

/* モーダル関連のスタイル */
.modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modalContent {
  background: white;
  padding: 2rem;
  border-radius: 25px;
  width: 90%;
  max-width: 800px;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  border: 2px solid #e0f2fe;
}

.modalHeader {
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid #e0f2fe;
}

.modalHeader h2 {
  margin: 0;
  color: #60a5fa;
  font-size: 1.8rem;
  font-weight: normal;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.formGroup {
  margin-bottom: 1.5rem;
}

.formGroup label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #444;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.formGroup input,
.formGroup select,
.formGroup textarea {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid #e0f2fe;
  border-radius: 15px;
  font-size: 1rem;
  transition: all 0.3s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.formGroup input:focus,
.formGroup select:focus,
.formGroup textarea:focus {
  outline: none;
  border-color: #60a5fa;
  box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
}

.checkboxGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-top: 0.5rem;
}

.checkboxLabel {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.95rem;
  color: #444;
  cursor: pointer;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.modalFooter {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 2px solid #e0f2fe;
}

.resetButton,
.cancelButton,
.applyButton {
  padding: 0.75rem 2rem;
  border: none;
  border-radius: 15px;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  font-weight: normal;
}

.resetButton {
  background-color: #f1f5f9;
  color: #64748b;
}

.resetButton:hover {
  background-color: #e0f2fe;
}

.cancelButton {
  background: linear-gradient(135deg, #94a3b8, #cbd5e1);
  color: white;
}

.cancelButton:hover {
  background: linear-gradient(135deg, #cbd5e1, #94a3b8);
}

.applyButton {
  background: linear-gradient(135deg, #60a5fa, #93c5fd);
  color: white;
}

.applyButton:hover {
  background: linear-gradient(135deg, #93c5fd, #60a5fa);
}

/* レスポンシブデザイン */
@media (max-width: 1440px) {
  .contentWrapper {
    max-width: calc(100% - 4rem);
  }
}

@media (max-width: 1200px) {
  .eventsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .container {
    padding: 1rem;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }

  .headerButtons {
    width: 100%;
    flex-direction: column;
  }

  .backButton,
  .logoutButton {
    width: 100%;
    text-align: center;
  }

  .searchBar {
    flex-direction: column;
  }

  .searchButton,
  .advancedSearchButton {
    width: 100%;
  }

  .sortContainer {
    flex-direction: column;
  }

  .eventsGrid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }

  .modalContent {
    padding: 1.5rem;
    width: 95%;
  }
}

@media (max-width: 480px) {
  .container {
    padding: 0.75rem;
  }

  .title {
    font-size: 1.1rem;
  }

  .description {
    font-size: 0.9rem;
  }
}
</file>

<file path="app/types/index.ts">
/**
 * イベント関連の型定義をエクスポート
 * すべての型定義はevent.tsで管理されています
 */
export * from './event';
</file>

<file path="app/globals.css">
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

:root {
  /* メインカラー */
  --primary-blue: #6B9BD2;    /* より濃いめの青 */
  --primary-pink: #FF9EAF;    /* 明るい桃色 */
  --primary-yellow: #FFD23F;  /* 元気な黄色 */
  --primary-green: #98D8AA;   /* 爽やかな緑 */
  
  /* アクセントカラー */
  --accent-salmon: #FF6B6B;   /* はっきりとした赤 */
  --accent-orange: #FFA41B;   /* 温かみのあるオレンジ */

  /* テキストカラー */
  --text-primary: #333333;    /* 濃い目のグレー */
  --text-secondary: #555555;  /* 中間のグレー */
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Courier Prime', monospace;
  background-color: #FFFFFF;
  color: var(--text-primary);
  line-height: 1.6;
}

/* For WebKit browsers */
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: #FFFFFF;
  border-left: 2px solid var(--primary-blue);
}

::-webkit-scrollbar-thumb {
  background: var(--primary-blue);
}

::-webkit-scrollbar-thumb:hover {
  background: var(--accent-salmon);
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}

a {
  color: inherit;
  text-decoration: none;
}

button {
  font-family: inherit;
}
</file>

<file path="app/page.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';
import styles from './page.module.css';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isLogin, setIsLogin] = useState(true);
  const router = useRouter();

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (isLogin) {
        const { error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) throw error;
        router.push('/main');
      } else {
        const { error } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { name },
            emailRedirectTo: `${window.location.origin}/auth/callback`
          }
        });

        if (error) throw error;
        setIsLogin(true);
        setEmail('');
        setPassword('');
        setName('');
        setError('新規登録が完了しました。ログインしてください。');
        return;
      }
    } catch (error: any) {
      setError(isLogin ? 'ログインに失敗しました。メールアドレスとパスワードを確認してください。' : '新規登録に失敗しました。入力内容を確認してください。');
    }
  };

  return (
    <div className={styles.container}>
      <h1 className={styles.title}>保育士イベントアイディア</h1>
      <div className={styles.loginContainer}>
        <form onSubmit={handleSubmit}>
          {!isLogin && (
            <div className={styles.formGroup}>
              <label className={styles.label}>名前</label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required={!isLogin}
                className={styles.input}
                placeholder="山田 花子"
              />
            </div>
          )}
          <div className={styles.formGroup}>
            <label className={styles.label}>メールアドレス</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className={styles.input}
              placeholder="example@email.com"
            />
          </div>
          <div className={styles.formGroup}>
            <label className={styles.label}>パスワード</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className={styles.input}
              placeholder="••••••••"
            />
          </div>
          {error && <div className={`${styles.error} ${error.includes('完了') ? styles.success : ''}`}>{error}</div>}
          <button type="submit" className={styles.loginButton}>
            {isLogin ? 'ログイン' : '新規登録'}
          </button>
        </form>
        <div className={styles.signupLink}>
          {isLogin ? (
            <>アカウントをお持ちでない方は<button onClick={() => setIsLogin(false)} className={styles.switchButton}>新規登録</button></>
          ) : (
            <>アカウントをお持ちの方は<button onClick={() => setIsLogin(true)} className={styles.switchButton}>ログイン</button></>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/events/edit/[id]/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';
import EditEventForm from '../../../components/EditEventForm';
import type { Event, EventFormData, MediaFile } from '../../../types/event';
import { Metadata } from 'next';

// 編集フォームからのデータを受け取るための型
type EditFormData = Omit<EventFormData, 'media_files'> & {
  media_files: (MediaFile | File)[];
};

const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

const convertEventToFormData = (event: Event): EventFormData => {
  return {
    title: event.title,
    description: event.description,
    category: event.category,
    month: event.month,
    date: event.date,
    duration: event.duration,
    materials: event.materials,
    objectives: event.objectives,
    age_groups: event.age_groups,
    media_files: event.media_files,
    ...(event.id ? { id: event.id } : {})
  };
};

type Props = {
  params: { id: string };
  searchParams: Record<string, string | string[] | undefined>;
};

export default function EditEventPage({ params }: Props) {
  const [event, setEvent] = useState<Event | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const fetchEvent = async () => {
      try {
        setLoading(true);
        const { data: { session } } = await supabase.auth.getSession();
        
        if (!session) {
          router.push('/');
          return;
        }

        const { data: eventData, error: eventError } = await supabase
          .from('events')
          .select('*')
          .eq('id', params.id)
          .eq('user_id', session.user.id)
          .single();

        if (eventError) {
          if (eventError.code === 'PGRST116') {
            setError('イベントが見つかりませんでした');
          } else {
            setError(`データの取得中にエラーが発生しました: ${eventError.message}`);
          }
          return;
        }

        if (!eventData) {
          setError('イベントが見つかりませんでした');
          return;
        }

        setEvent(eventData);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : '予期せぬエラーが発生しました';
        setError(`予期せぬエラーが発生しました: ${errorMessage}`);
      } finally {
        setLoading(false);
      }
    };

    fetchEvent();
  }, [params.id, router]);

  const handleSubmit = async (formData: EditFormData) => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      
      if (!session) {
        router.push('/');
        return;
      }

      // durationが文字列の場合はそのまま使用
      // durationがオブジェクトの場合は文字列に変換
      let durationStr = '';
      if (typeof formData.duration === 'object') {
        const end = formData.duration.end;
        if (end) {
          const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            
            if (hours > 0) {
              durationStr += `${hours}時間`;
            }
            
            if (minutes > 0) {
              durationStr += `${minutes}分`;
            }
          }
        }
      } else {
        durationStr = formData.duration;
      }

      const { error } = await supabase
        .from('events')
        .update({
          title: formData.title,
          description: formData.description,
          category: formData.category,
          month: formData.month,
          date: formData.date,
          age_groups: formData.age_groups,
          duration: durationStr || '不明',
          materials: formData.materials,
          objectives: formData.objectives,
          updated_at: new Date().toISOString()
        })
        .eq('id', params.id)
        .eq('user_id', session.user.id);

      if (error) throw error;
      router.push('/events');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '予期せぬエラーが発生しました';
      setError(`更新中にエラーが発生しました: ${errorMessage}`);
    }
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  if (!event) {
    return <div>Event not found</div>;
  }

  return (
    <EditEventForm
      data={convertEventToFormData(event)}
      onSubmit={handleSubmit}
      onCancel={() => router.push('/events')}
    />
  );
}
</file>

<file path="README.md">
# 保育士イベントアイディア

保育士さんのための、イベントアイディア共有プラットフォーム。
日々の保育業務に役立つイベントのアイディアを共有し、保育の質の向上を目指します。

## アプリ概要

保育現場では、子どもたちの成長を促すための様々なイベントが行われています。
しかし、新しいアイディアを考えることや、年齢に適したイベントを企画することは、時として大変な作業です。

このアプリは、そんな保育士さんたちとイベントのアイディアを共有し、他の保育士さんの経験や知恵を活かすことで、より良い保育環境づくりをサポートします。

## アプリの使い方

1. アカウント作成・ログイン
   - 新規登録：メールアドレスとパスワードで登録
   - テストアカウント：
     - メール：test-email@example.com
     - パスワード：test123

2. イベントの閲覧
   - トップページで人気のイベントを確認
   - 年齢別にイベントを絞り込み
   - キーワードで検索

3. イベントの投稿
   - タイトル、説明、対象年齢を入力
   - 画像をアップロード（任意）
   - 所要時間や準備物を記載



## 使用技術・ライブラリ

- フロントエンド
  - React
  - Next.js 14
  - TypeScript
  - CSS Modules

- バックエンド
  - Supabase
    - Authentication
    - Database
    - Storage

- デプロイ
  - Vercel

## 工夫した点

1. UX/UIデザイン
   - 保育現場をイメージした温かみのあるデザイン
   - 直感的な操作性を重視
   - レスポンシブ対応で様々なデバイスに対応

2. 機能面
   - 年齢別フィルタリングで必要な情報にすぐアクセス
   - 画像プレビュー機能で投稿をスムーズに
   - ビュー数による人気イベントの表示


## 苦労した点

1. TypeScriptの型定義
   - Supabaseとの連携における型の管理
   - コンポーネント間のデータの受け渡し

2. 画像処理
   - アップロード時の最適化
   - プレビュー表示の実装

3. レイアウト調整
   - 異なるデバイスでの表示の一貫性確保
   - アニメーションの実装

## 今後追加予定の機能

1. イベントの評価・コメント
   - 「いいね」機能で評価
   - コメントで感想や改善点を共有

2. コミュニティ機能
   - 保育士同士の交流の場
   - 質問・相談機能

3. テンプレート機能
   - よく使うイベント形式の保存
   - クイックポスト機能

4. 分析機能
   - 年齢別人気イベントの統計
   - 季節別イベントの傾向分析

## スクリーンショット

[ログイン画面]
[メイン画面]
[イベント詳細画面]
[投稿画面]

※実際の画面のスクリーンショットを追加予定
</file>

<file path="app/types.ts">
export type Category = '壁　面' | '制作物' | 'その他';
export type AgeGroup = '0歳児' | '1歳児' | '2歳児' | '3歳児' | '4歳児' | '5歳児';

export type MediaFile = {
  type: string;
  url: string;
};

export type LocalMediaFile = File;

export type Event = {
  id: string;
  title: string;
  description: string;
  month: number;
  category: string;
  age_groups: AgeGroup[];
  duration: string;
  materials: string[];
  objectives: string[];
  media_files: MediaFile[];
  views: number;
  image_url?: string;
  created_at?: string;
  updated_at?: string;
  user_id: string;
};

export type EventFormData = Omit<Event, 'id' | 'user_id' | 'created_at' | 'updated_at' | 'views'>;

export type LocalEventFormData = Omit<Event, 'id' | 'user_id' | 'created_at' | 'updated_at' | 'views' | 'media_files'> & {
  media_files: LocalMediaFile[];
};

export interface User {
  id: string;
  email: string;
  name?: string;
}

export interface AuthError {
  message: string;
  code?: string;
}

export interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: AuthError | null;
  signIn: (email: string, password: string) => Promise<{ error?: AuthError }>;
  signUp: (email: string, password: string, name: string) => Promise<{ error?: AuthError }>;
  signOut: () => Promise<void>;
}
</file>

<file path="app/components/EventOverlay.tsx">
'use client';

import React, { useEffect, useState, useRef } from 'react';
import styles from './EventOverlay.module.css';
import type { Event } from '../types/event';
import { createBrowserClient } from '@supabase/ssr';
import Image from 'next/image';

const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

type EventOverlayProps = {
  event: Event;
  onClose: () => void;
  onDelete: (id: string) => void;
  onEdit: () => void;
  season?: 'spring' | 'summer' | 'autumn' | 'winter';
};

const formatDate = (dateString: string | undefined) => {
  if (!dateString) return '日付なし';
  return new Date(dateString).toLocaleDateString('ja-JP');
};

// 年齢グループをソートする関数を追加
const sortAgeGroups = (ages: string[]) => {
  const ageOrder = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'];
  return [...ages].sort((a, b) => ageOrder.indexOf(a) - ageOrder.indexOf(b));
};

// 所要時間をフォーマットする関数
const formatDuration = (duration: { start?: string, end?: string } | string | null | undefined) => {
  // 値が存在しない場合
  if (!duration) return '不明';
  
  // 文字列の場合はJSONとしてパース
  if (typeof duration === 'string') {
    try {
      const parsedDuration = JSON.parse(duration);
      return formatDuration(parsedDuration);
    } catch (e) {
      // 時間と分を抽出（例: "2時間30分"）
      const durationStr = duration as string;
      const hoursMatch = durationStr.match(/(\d+)時間/);
      const minutesMatch = durationStr.match(/(\d+)分/);
      
      if (hoursMatch || minutesMatch) {
        const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
        const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
        
        if (hours > 0 && minutes > 0) {
          return `${hours}時間${minutes}分`;
        } else if (hours > 0) {
          return `${hours}時間`;
        } else if (minutes > 0) {
          return `${minutes}分`;
        }
      }
      return durationStr;
    }
  }
  
  // オブジェクトの場合はend値を使う
  const durationObj = duration as { start?: string, end?: string };
  const end = durationObj.end;
  if (!end) return '不明';
  
  // HH:MM形式の場合
  const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1]);
    const minutes = parseInt(timeMatch[2]);
    
    if (hours > 0 && minutes > 0) {
      return `${hours}時間${minutes}分`;
    } else if (hours > 0) {
      return `${hours}時間`;
    } else if (minutes > 0) {
      return `${minutes}分`;
    }
  }
  
  return end;
};

export default function EventOverlay({ event, onClose, onDelete, onEdit, season = 'spring' }: EventOverlayProps) {
  const [isDeleting, setIsDeleting] = useState(false);
  const overlayRef = useRef<HTMLDivElement>(null);

  // イベントの所有者かどうかを確認
  const isOwner = event.isOwner;

  const handleDelete = () => {
    setIsDeleting(true);
    onDelete(event.id);
  };

  useEffect(() => {
    const updateViewCount = async () => {
      try {
        // セッションの確認
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) {
          console.log('セッションが存在しません');
          return;
        }

        // 閲覧数を更新
        const { error: updateError } = await supabase
          .from('events')
          .update({ 
            views: (event.views || 0) + 1,
            updated_at: new Date().toISOString()
          })
          .eq('id', event.id);
        
        if (updateError) {
          console.error('閲覧回数の更新に失敗しました:', updateError.message);
          return;
        }
      } catch (error) {
        console.error('閲覧回数の更新中にエラーが発生しました:', error);
      }
    };

    updateViewCount();
  }, [event.id, event.views]);

  return (
    <div className={styles.overlay} onClick={onClose}>
      <div 
        className={`${styles.content} ${styles[season]}`} 
        onClick={e => e.stopPropagation()}
        ref={overlayRef}
      >
        <button className={styles.closeButton} onClick={onClose}>×</button>
        
        <div className={styles.header}>
          <div className={styles.categoryLabel} data-category={event.category}>
            {event.category}
          </div>
          <h2 className={styles.title}>{event.title}</h2>
        </div>

        <div className={styles.meta}>
          <div className={styles.ageTags}>
            {sortAgeGroups(event.age_groups).map((age: string, index: number) => (
              <span key={index} className={styles.ageTag} data-age={age}>
                {age}
              </span>
            ))}
          </div>
          <span className={styles.duration}>所要時間：{formatDuration(event.duration)}</span>
        </div>

        {/* メディアファイル（画像・動画）の表示 */}
        {event.media_files && event.media_files.length > 0 && (
          <div className={styles.mediaSection}>
            <h3 className={styles.sectionTitle}>画像・動画</h3>
            <div className={styles.mediaGallery}>
              {event.media_files.map((media, index) => (
                <div key={index} className={styles.mediaItem}>
                  {media.type === 'image' ? (
                    <Image 
                      src={media.url} 
                      alt={`${event.title}の画像 ${index + 1}`} 
                      className={styles.mediaImage}
                      width={500}
                      height={300}
                    />
                  ) : media.type === 'video' ? (
                    <video 
                      src={media.url} 
                      controls
                      className={styles.mediaVideo}
                    />
                  ) : null}
                </div>
              ))}
            </div>
          </div>
        )}

        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>説明</h3>
          <p className={styles.description}>{event.description}</p>
        </div>

        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>準備物</h3>
          <ul className={styles.materials}>
            {event.materials.map((material: string, index: number) => (
              <li key={index}>{material}</li>
            ))}
          </ul>
        </div>

        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>目的</h3>
          <ul className={styles.objectives}>
            {event.objectives.map((objective: string, index: number) => (
              <li key={index}>{objective}</li>
            ))}
          </ul>
        </div>

        <div className={styles.eventFooter}>
          <div className={styles.eventStats}>
            <span className={styles.dateInfo}>
              作成日: {formatDate(event.created_at)}
            </span>
            <span className={styles.separator}>|</span>
            <span className={styles.authorInfo}>
              投稿者: {event.profiles?.name || '不明'}
            </span>
            <span className={styles.separator}>|</span>
            <span className={styles.viewCount}>
              閲覧数: {event.views || 0}
            </span>
          </div>

          {isOwner && (
            <div className={styles.eventActions}>
              <button onClick={onEdit} className={styles.editButton}>
                編集
              </button>
              <button
                onClick={handleDelete}
                className={`${styles.deleteButton} ${isDeleting ? styles.deleting : ''}`}
                disabled={isDeleting}
              >
                {isDeleting ? '削除中...' : '削除'}
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/MonthCard.module.css">
.monthCard {
  background: white;
  border-radius: 25px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 15px;
  border: 2px solid transparent;
  position: relative;
  overflow: hidden;
  min-height: 400px;
}

.monthCard::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 8px;
  background: linear-gradient(to right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.2));
  border-radius: 25px 25px 0 0;
}

.monthCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
}

/* 月ごとのカラー設定 */
.january {
  border-color: #FF6B6B;  /* 明るい赤（お正月） */
  background: linear-gradient(135deg, #fff, #fff5f5);
}

.january .monthHeader {
  border-bottom-color: #FF6B6B;
}

.january .eventItem {
  background: linear-gradient(135deg, #fff, #fff5f5);
  border-color: rgba(255, 107, 107, 0.3);
}

.february {
  border-color: #4A90E2;  /* 明るい青（寒空） */
  background: linear-gradient(135deg, #fff, #f5f8ff);
}

.february .monthHeader {
  border-bottom-color: #4A90E2;
}

.february .eventItem {
  background: linear-gradient(135deg, #fff, #f5f8ff);
  border-color: rgba(74, 144, 226, 0.3);
}

.march {
  border-color: #FF9FB2;  /* 優しい桜色 */
  background: linear-gradient(135deg, #fff, #fff5f7);
}

.march .monthHeader {
  border-bottom-color: #FF9FB2;
}

.march .eventItem {
  background: linear-gradient(135deg, #fff, #fff5f7);
  border-color: rgba(255, 159, 178, 0.3);
}

.april {
  border-color: #7ED321;  /* 明るい若草色 */
  background: linear-gradient(135deg, #fff, #f7fff0);
}

.april .monthHeader {
  border-bottom-color: #7ED321;
}

.april .eventItem {
  background: linear-gradient(135deg, #fff, #f7fff0);
  border-color: rgba(126, 211, 33, 0.3);
}

.may {
  border-color: #4FD1C5;  /* 明るいターコイズ */
  background: linear-gradient(135deg, #fff, #f0fffd);
}

.may .monthHeader {
  border-bottom-color: #4FD1C5;
}

.may .eventItem {
  background: linear-gradient(135deg, #fff, #f0fffd);
  border-color: rgba(79, 209, 197, 0.3);
}

.june {
  border-color: #9B6DFF;  /* 明るい紫（あじさい） */
  background: linear-gradient(135deg, #fff, #f8f5ff);
}

.june .monthHeader {
  border-bottom-color: #9B6DFF;
}

.june .eventItem {
  background: linear-gradient(135deg, #fff, #f8f5ff);
  border-color: rgba(155, 109, 255, 0.3);
}

.july {
  border-color: #54C7FC;  /* 爽やかな空色 */
  background: linear-gradient(135deg, #fff, #f0faff);
}

.july .monthHeader {
  border-bottom-color: #54C7FC;
}

.july .eventItem {
  background: linear-gradient(135deg, #fff, #f0faff);
  border-color: rgba(84, 199, 252, 0.3);
}

.august {
  border-color: #FFB347;  /* 明るいオレンジ（太陽） */
  background: linear-gradient(135deg, #fff, #fff7f0);
}

.august .monthHeader {
  border-bottom-color: #FFB347;
}

.august .eventItem {
  background: linear-gradient(135deg, #fff, #fff7f0);
  border-color: rgba(255, 179, 71, 0.3);
}

.september {
  border-color: #4CAF50;  /* 明るい緑 */
  background: linear-gradient(135deg, #fff, #f0fff1);
}

.september .monthHeader {
  border-bottom-color: #4CAF50;
}

.september .eventItem {
  background: linear-gradient(135deg, #fff, #f0fff1);
  border-color: rgba(76, 175, 80, 0.3);
}

.october {
  border-color: #FFB74D;  /* 明るい金茶色 */
  background: linear-gradient(135deg, #fff, #fff8f0);
}

.october .monthHeader {
  border-bottom-color: #FFB74D;
}

.october .eventItem {
  background: linear-gradient(135deg, #fff, #fff8f0);
  border-color: rgba(255, 183, 77, 0.3);
}

.november {
  border-color: #FF7043;  /* 明るい茶色（紅葉） */
  background: linear-gradient(135deg, #fff, #fff5f0);
}

.november .monthHeader {
  border-bottom-color: #FF7043;
}

.november .eventItem {
  background: linear-gradient(135deg, #fff, #fff5f0);
  border-color: rgba(255, 112, 67, 0.3);
}

.december {
  border-color: #5C6BC0;  /* 明るい紺色 */
  background: linear-gradient(135deg, #fff, #f5f6ff);
}

.december .monthHeader {
  border-bottom-color: #5C6BC0;
}

.december .eventItem {
  background: linear-gradient(135deg, #fff, #f5f6ff);
  border-color: rgba(92, 107, 192, 0.3);
}

.monthHeader {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 15px;
  text-align: center;
  border-bottom: 3px solid transparent;
  padding-bottom: 8px;
  position: relative;
}

.monthTitle {
  font-size: 1.6rem;
  font-weight: bold;
  color: #444;
  font-family: "M PLUS Rounded 1c", sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin: 0;
  padding: 8px 0;
}

.monthDecoration {
  margin: 0 6px;
  font-size: 0.7em;
}

.monthDecoration.left {
  left: -20px;
}

.monthDecoration.right {
  right: -20px;
}

/* 冬の装飾 */
.winterDecoration {
  color: #B0E0E6;
}

/* 春の装飾 */
.springDecoration {
  color: #FFB5C5;
}

/* 夏の装飾 */
.summerDecoration {
  color: #87CEEB;
}

/* 秋の装飾 */
.autumnDecoration {
  color: #FFB347;
}

/* 月タイトルの before/after を削除 */
.monthTitle::before,
.monthTitle::after {
  content: none;
}

.categoryLabels {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.categorySection {
  display: flex;
  flex-direction: column;
  gap: 10px;
  position: relative;
  margin-bottom: 15px;
}

.categorySection:hover {
  background: rgba(255, 255, 255, 0.8);
}

.categoryLabel {
  font-size: 0.9rem;
  padding: 4px 12px;
  border-radius: 20px;
  color: white;
  font-weight: 500;
  text-align: center;
  letter-spacing: 0.02em;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  white-space: nowrap;
  min-width: 80px;
  flex-shrink: 0;
}

.wallColumn {
  background: #A7D2FF;
}

.craftColumn {
  background: #FFB5C5;
}

.otherColumn {
  background: #B5E6B5;
}

.eventsContainer {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: 15px;
  margin-bottom: 60px;
}

.eventItem {
  cursor: pointer;
  padding: 1rem;
  border-radius: 8px;
  background-color: white;
  transition: all 0.3s ease;
  border: 1px solid #e2e8f0;
}

.eventItem::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, rgba(255, 181, 197, 0.5), rgba(135, 206, 235, 0.5));
  opacity: 0;
  transition: opacity 0.3s ease;
}

.eventItem:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.eventItem:hover::after {
  opacity: 1;
}

.eventHeader {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}

.eventTitle {
  margin: 0;
  font-size: 1rem;
  color: #444;
  font-weight: 600;
  line-height: 1.3;
  font-family: "M PLUS Rounded 1c", sans-serif;
  flex: 1;
}

.eventMeta {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-start;
  width: 100%;
}

.ageTags {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.ageTag {
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: 500;
  letter-spacing: 0.02em;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

/* 年齢タグの色分け */
.ageTag[data-age="0歳児"] {
  background-color: rgba(255, 182, 193, 0.15);
  color: #d4788f;
}

.ageTag[data-age="1歳児"] {
  background-color: rgba(255, 218, 185, 0.15);
  color: #d49a6a;
}

.ageTag[data-age="2歳児"] {
  background-color: rgba(176, 224, 230, 0.15);
  color: #6a9da3;
}

.ageTag[data-age="3歳児"] {
  background-color: rgba(144, 238, 144, 0.15);
  color: #5fa55f;
}

.ageTag[data-age="4歳児"] {
  background-color: rgba(230, 230, 250, 0.15);
  color: #8484b4;
}

.ageTag[data-age="5歳児"] {
  background-color: rgba(255, 239, 213, 0.15);
  color: #d4b48c;
}

.duration {
  color: #666;
  font-size: 0.9rem;
  background-color: rgba(0, 0, 0, 0.04);
  padding: 4px 12px;
  border-radius: 15px;
  font-family: "M PLUS Rounded 1c", sans-serif;
  margin-left: auto;
}

.emptyEvent {
  border: 2px dashed #e0e0e0;
  border-radius: 12px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 12px;
  min-height: 80px;
  background-color: rgba(255, 255, 255, 0.8);
  transition: all 0.3s ease;
}

.emptyEvent:hover {
  border-color: #FFB5C5;
  background-color: rgba(255, 255, 255, 0.9);
}

.emptyEvent .categoryLabel {
  font-size: 0.8rem;
  padding: 4px 12px;
  min-width: 70px;
}

.noEvents {
  color: #888;
  margin: 0;
  font-size: 0.9rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
  flex: 1;
}

/* イベント追加ボタンのスタイル（単色） */
.january .addButton { background-color: #FF6B6B; }
.february .addButton { background-color: #4A90E2; }
.march .addButton { background-color: #FF9FB2; }
.april .addButton { background-color: #7ED321; }
.may .addButton { background-color: #4FD1C5; }
.june .addButton { background-color: #9B6DFF; }
.july .addButton { background-color: #54C7FC; }
.august .addButton { background-color: #FFB347; }
.september .addButton { background-color: #4CAF50; }
.october .addButton { background-color: #FFB74D; }
.november .addButton { background-color: #FF7043; }
.december .addButton { background-color: #5C6BC0; }

.addButton {
  width: auto;
  padding: 12px 40px;
  color: white;
  border: none;
  border-radius: 25px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: auto auto 0;
  display: block;
}

.addButton:hover {
  transform: translateY(-2px);
  opacity: 0.9;
}

/* レスポンシブデザイン */
@media (max-width: 768px) {
  .monthCard {
    padding: 15px;
  }

  .categoryLabels {
    flex-wrap: wrap;
  }

  .eventItem,
  .emptyEvent {
    min-height: 80px;
    padding: 12px;
  }

  .monthTitle {
    font-size: 1.6rem;
  }

  .eventTitle {
    font-size: 1rem;
  }

  .ageTag {
    font-size: 0.8rem;
    padding: 3px 8px;
  }

  .duration {
    font-size: 0.85rem;
  }

  .addButton {
    width: 180px;
    padding: 10px 30px;
  }
}

.blueDecoration {
  color: #4a90e2;
}

.pinkDecoration {
  color: #ff9a9e;
}

.greenDecoration {
  color: #68d391;
}

.yellowDecoration {
  color: #f6e05e;
}

.purpleDecoration {
  color: #9f7aea;
}

.orangeDecoration {
  color: #ed8936;
}

.brownDecoration {
  color: #b7791f;
}

.silverDecoration {
  color: #a0aec0;
}

.defaultDecoration {
  color: #718096;
}

.newEvent {
  animation: highlight 2s ease-in-out;
}

@keyframes highlight {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  }
  50% {
    transform: scale(1.02);
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  }
}
</file>

<file path="app/page.module.css">
.container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  background: #FFFFFF;
  position: relative;
  overflow-x: hidden;
  padding: 0;
  margin: 0;
  width: 100%;
  box-sizing: border-box;
}

.container::before {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  background-image: 
    /* ピンクのドット */
    radial-gradient(#FFB5C5 105px, transparent 105px),
    radial-gradient(#FFB5C5 95px, transparent 95px),
    radial-gradient(#FFB5C5 85px, transparent 85px),
    /* 水色のドット */
    radial-gradient(#B5E6FF 90px, transparent 90px),
    radial-gradient(#B5E6FF 85px, transparent 85px),
    radial-gradient(#B5E6FF 80px, transparent 80px),
    radial-gradient(#B5E6FF 75px, transparent 75px),
    /* 緑のドット */
    radial-gradient(#98FB98 85px, transparent 85px),
    radial-gradient(#98FB98 80px, transparent 80px),
    radial-gradient(#98FB98 75px, transparent 75px),
    /* 黄色のドット */
    radial-gradient(#FFD700 80px, transparent 80px),
    radial-gradient(#FFD700 75px, transparent 75px),
    radial-gradient(#FFD700 70px, transparent 70px);
  background-position: 
    /* ピンクの位置 */
    5% 5%,
    85% 45%,
    45% 85%,
    /* 水色の位置 */
    95% 5%,
    25% 35%,
    75% 15%,
    5% 95%,
    /* 緑の位置 */
    65% 65%,
    35% 15%,
    95% 45%,
    /* 黄色の位置 */
    15% 35%,
    45% 65%,
    75% 75%;
  background-size: 
    /* ピンク */
    30% 30%,
    25% 25%,
    20% 20%,
    /* 水色 */
    30% 30%,
    25% 25%,
    20% 20%,
    25% 25%,
    /* 緑 */
    25% 25%,
    20% 20%,
    25% 25%,
    /* 黄色 */
    25% 25%,
    20% 20%,
    25% 25%;
  background-repeat: no-repeat;
  opacity: 0.12;
}

.title {
  margin: 15vh auto 0;
  font-size: 2.8rem;
  color: #FF8C42;
  text-align: center;
  font-family: "M PLUS Rounded 1c", sans-serif;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  padding: 0 1rem 1rem;
  position: relative;
  width: fit-content;
  box-sizing: border-box;
}

.title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 4px;
  background: #FFB800;
  border-radius: 2px;
}

.loginContainer {
  margin: 5vh auto 0;
  background: rgba(255, 255, 255, 0.95);
  padding: 2rem;
  border-radius: 20px;
  width: 90%;
  max-width: 400px;
  border: 2px dashed #FFB5C5;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  position: relative;
  box-sizing: border-box;
}

.loginContainer::before,
.loginContainer::after {
  content: '';
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  opacity: 0.7;
}

.loginContainer::before {
  top: -15px;
  left: -15px;
  background: #FFB5C5;
  border: 2px solid #FFB5C5;
}

.loginContainer::after {
  bottom: -15px;
  right: -15px;
  background: #B5E6FF;
  border: 2px solid #B5E6FF;
}

.formWrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  position: relative;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

.formGroup {
  margin-bottom: 1.5rem;
  width: 100%;
}

.label {
  display: block;
  margin-bottom: 0.5rem;
  color: #666;
  font-size: 0.9rem;
  font-family: "M PLUS Rounded 1c", sans-serif;
}

.input {
  width: 100%;
  padding: 0.8rem;
  border: 2px solid #FFE5D4;
  border-radius: 12px;
  font-size: 1rem;
  transition: all 0.3s ease;
  background: rgba(255, 255, 255, 0.9);
  box-sizing: border-box;
}

.input::placeholder {
  color: transparent;
}

.input:focus {
  outline: none;
  border-color: #FFB5C5;
  box-shadow: 0 0 0 3px rgba(255, 181, 197, 0.2);
}

.loginButton {
  width: 100%;
  padding: 1rem;
  background: linear-gradient(135deg, #B5E6FF, #6B9BD2);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: "M PLUS Rounded 1c", sans-serif;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
}

.loginButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(107, 155, 210, 0.3);
}

.loginButton:active {
  transform: translateY(0);
}

.signupLink {
  text-align: center;
  margin-top: 1rem;
  font-size: 0.9rem;
  color: #666;
}

.signupLink a {
  color: #FFB5C5;
  text-decoration: none;
  font-weight: bold;
  transition: all 0.3s ease;
}

.signupLink a:hover {
  color: #FF8C42;
  text-decoration: underline;
}

.error {
  color: #FF4B4B;
  font-size: 0.9rem;
  margin-top: 0.5rem;
  text-align: center;
  padding: 0.5rem;
  border-radius: 8px;
  background: rgba(255, 75, 75, 0.1);
}

.success {
  color: #4CAF50;
  background: rgba(76, 175, 80, 0.1);
}

@media (max-width: 768px) {
  .loginContainer {
    margin: 0 1rem;
  }
  
  .title {
    font-size: 2rem;
  }
}

.authContainer {
  width: 100%;
  max-width: 400px;
  background-color: #FFFFFF;
  border: 4px solid var(--primary-blue);
  border-radius: 12px;
  padding: 40px;
  position: relative;
  box-shadow: 
    0 4px 6px rgba(107, 155, 210, 0.1),
    0 0 0 8px rgba(107, 155, 210, 0.05);
}

.formTitle {
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 30px;
  text-align: center;
  color: var(--text-primary);
  position: relative;
  display: inline-block;
  width: 100%;
}

.button {
  width: 100%;
  padding: 15px;
  background-color: var(--primary-blue);
  color: #FFFFFF;
  border: none;
  border-radius: 8px;
  font-family: 'Courier New', monospace;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
  box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
}

.button:hover {
  background-color: var(--accent-salmon);
  transform: translateY(-2px);
  box-shadow: 0 6px 0 rgba(0, 0, 0, 0.1);
}

.button:active {
  transform: translateY(0);
  box-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
}

.switchText {
  margin-top: 20px;
  text-align: center;
  font-weight: bold;
  cursor: pointer;
  color: var(--text-primary);
  transition: color 0.3s ease;
  text-decoration: underline;
  text-decoration-color: var(--primary-blue);
  text-decoration-thickness: 2px;
  text-underline-offset: 4px;
}

.switchText:hover {
  color: var(--accent-salmon);
  text-decoration-color: var(--accent-salmon);
}

.errorMessage {
  background-color: #FFFFFF;
  border: 3px solid var(--accent-salmon);
  border-radius: 8px;
  color: var(--accent-salmon);
  padding: 15px;
  margin-bottom: 20px;
  font-weight: bold;
  text-align: center;
  box-shadow: 0 2px 4px rgba(255, 107, 107, 0.1);
}

.loadingContainer {
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #FFFFFF;
  position: relative;
}

.loading {
  font-family: 'Courier New', monospace;
  font-size: 20px;
  color: #000000;
  padding: 20px;
  border: 4px solid #000000;
  background-color: #FFFFFF;
  transform: rotate(-1deg);
  transition: transform 0.3s ease;
}

.loading:hover {
  transform: rotate(0deg);
}

.loginBox {
  background: white;
  padding: 2.5rem;
  border-radius: 16px;
  box-shadow: 0 8px 16px rgba(107, 155, 210, 0.1);
  border: 2px dashed #6B9BD2;
  width: 90%;
  max-width: 400px;
  position: relative;
  z-index: 1;
}

.description {
  width: 100%;
  max-width: 800px;
  background-color: rgba(255, 255, 255, 0.9);
  padding: 25px 30px;
  border-radius: 15px;
  font-size: 1rem;
  line-height: 1.8;
  color: #666;
  margin: 30px auto;
  position: relative;
  border: 2px dashed #FFB5C5;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

/* グラデーション背景を削除してシンプルに */
.description::before {
  content: none;
}

/* アニメーション */
@keyframes float {
  0% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0px);
  }
}

/* 装飾要素も整理 */
.decoration {
  display: none;
}

.switchButton {
  background: none;
  border: none;
  color: #FFB5C5;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
  padding: 0;
  margin: 0;
  font-size: inherit;
  transition: all 0.3s ease;
}

.switchButton:hover {
  color: #FF8C42;
  text-decoration: underline;
}
</file>

<file path="app/components/MonthCard.tsx">
'use client';

import React from 'react';
import styles from './MonthCard.module.css';
import { Event, Category } from '../types/event';
import { useRouter } from 'next/navigation';

interface MonthCardProps {
  month: number;
  monthName: string;
  events: Event[];
  onEventClick: (event: Event) => void;
  onAddClick: () => void;
  season?: 'spring' | 'summer' | 'autumn' | 'winter';
  newEventId?: string | null;
}

const CATEGORIES: Category[] = ['壁　面', '制作物', 'その他'];

// 年齢グループをソートする関数
const sortAgeGroups = (ages: string[] = []) => {
  const ageOrder = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'];
  return [...ages].sort((a, b) => ageOrder.indexOf(a) - ageOrder.indexOf(b));
};

const getMonthClass = (month: number): string => {
  switch (month) {
    case 1: return styles.january;
    case 2: return styles.february;
    case 3: return styles.march;
    case 4: return styles.april;
    case 5: return styles.may;
    case 6: return styles.june;
    case 7: return styles.july;
    case 8: return styles.august;
    case 9: return styles.september;
    case 10: return styles.october;
    case 11: return styles.november;
    case 12: return styles.december;
    default: return '';
  }
};

const formatDate = (dateString: string | undefined) => {
  if (!dateString) return '';
  return new Date(dateString).toLocaleDateString('ja-JP');
};

const sortEventsByDate = (events: Event[]) => {
  return [...events].sort((a, b) => {
    const dateA = a.created_at ? new Date(a.created_at).getTime() : 0;
    const dateB = b.created_at ? new Date(b.created_at).getTime() : 0;
    return dateB - dateA;
  });
};

// 所要時間をフォーマットする関数
const formatDuration = (duration: { start?: string, end?: string } | string | null | undefined) => {
  // 値が存在しない場合
  if (!duration) return '不明';
  
  // 文字列の場合はJSONとしてパース
  if (typeof duration === 'string') {
    try {
      const parsedDuration = JSON.parse(duration);
      return formatDuration(parsedDuration);
    } catch (e) {
      // 時間と分を抽出（例: "2時間30分"）
      const durationStr = duration as string;
      const hoursMatch = durationStr.match(/(\d+)時間/);
      const minutesMatch = durationStr.match(/(\d+)分/);
      
      if (hoursMatch || minutesMatch) {
        const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
        const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
        
        if (hours > 0 && minutes > 0) {
          return `${hours}時間${minutes}分`;
        } else if (hours > 0) {
          return `${hours}時間`;
        } else if (minutes > 0) {
          return `${minutes}分`;
        }
      }
      return durationStr;
    }
  }
  
  // オブジェクトの場合はend値を使う
  const durationObj = duration as { start?: string, end?: string };
  const end = durationObj.end;
  if (!end) return '不明';
  
  // HH:MM形式の場合
  const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1]);
    const minutes = parseInt(timeMatch[2]);
    
    if (hours > 0 && minutes > 0) {
      return `${hours}時間${minutes}分`;
    } else if (hours > 0) {
      return `${hours}時間`;
    } else if (minutes > 0) {
      return `${minutes}分`;
    }
  }
  
  return end;
};

export const MonthCard: React.FC<MonthCardProps> = ({
  month,
  monthName,
  events,
  onEventClick,
  onAddClick,
  newEventId
}) => {
  const monthClass = getMonthClass(month);

  const getLatestEventByCategory = (events: Event[], category: Category) => {
    // カテゴリーの正規化（全角スペースと空白を考慮）
    const normalizedCategory = category.replace(/\s+/g, '　').trim();
    
    return events.filter(event => {
      // カテゴリー判定ロジック
      const eventCategory = event.category?.replace(/\s+/g, '　').trim() || '';
      
      // 「その他」カテゴリーの場合
      if (normalizedCategory === 'その他') {
        return eventCategory !== '壁　面' && eventCategory !== '制作物';
      }

      return eventCategory === normalizedCategory;
    })
    .sort((a, b) => {
      const dateA = a.created_at ? new Date(a.created_at).getTime() : 0;
      const dateB = b.created_at ? new Date(b.created_at).getTime() : 0;
      return dateB - dateA;
    })[0];
  };

  return (
    <div className={`${styles.monthCard} ${monthClass}`}>
      <div className={styles.monthHeader}>
        <h3 className={styles.monthTitle}>
          {monthName}
        </h3>
      </div>
      <div className={styles.eventsContainer}>
        {CATEGORIES.map(category => {
          const event = getLatestEventByCategory(events, category);
          const columnStyle = category === '壁　面' ? 'wallColumn' : 
                            category === '制作物' ? 'craftColumn' : 'otherColumn';
          
          return (
            <div key={category} className={styles.categorySection}>
              {event ? (
                <div 
                  className={`${styles.eventItem} ${event.id === newEventId ? styles.newEvent : ''}`} 
                  onClick={() => onEventClick(event)}
                >
                  <div className={styles.eventHeader}>
                    <div className={`${styles.categoryLabel} ${styles[columnStyle]}`}>
                      {category}
                    </div>
                    <h3 className={styles.eventTitle}>{event.title}</h3>
                  </div>
                  <div className={styles.eventMeta}>
                    <div className={styles.ageTags}>
                      {sortAgeGroups(event.age_groups).map((age, index) => (
                        <span key={`${age}-${index}`} className={styles.ageTag} data-age={age}>{age}</span>
                      ))}
                    </div>
                    <span className={styles.duration}>所要時間：{formatDuration(event.duration)}</span>
                  </div>
                </div>
              ) : (
                <div className={styles.emptyEvent}>
                  <div className={`${styles.categoryLabel} ${styles[columnStyle]}`}>
                    {category}
                  </div>
                  <p className={styles.noEvents}>イベントの登録はありません</p>
                </div>
              )}
            </div>
          );
        })}
      </div>
      <button
        className={`${styles.addButton} ${styles.defaultButton}`}
        onClick={onAddClick}
      >
        ＋ イベントを追加
      </button>
    </div>
  );
};

export default MonthCard;
</file>

<file path="app/components/AddEventForm.tsx">
'use client';

import React, { useState, useRef, useEffect } from 'react';
import styles from './AddEventForm.module.css';
import { Event, EventFormData, AgeGroup, Category, LocalEventFormData } from '../types/event';

interface AddEventFormProps {
  onSubmit: (data: LocalEventFormData) => void | Promise<void>;
  onCancel: () => void;
  selectedMonth: number;
}

const AGE_GROUPS: AgeGroup[] = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'];
const CATEGORIES = ['壁　面', '制作物', 'その他'] as const;

const defaultCategory: Category = '壁　面';

export default function AddEventForm({ onSubmit, onCancel, selectedMonth }: AddEventFormProps) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [ageGroups, setAgeGroups] = useState<AgeGroup[]>([]);
  const [category, setCategory] = useState<Category>(defaultCategory);
  const [otherCategory, setOtherCategory] = useState('');
  const [hours, setHours] = useState('');
  const [minutes, setMinutes] = useState('');
  const [materials, setMaterials] = useState<string[]>([]);
  const [objectives, setObjectives] = useState<string[]>([]);
  const [files, setFiles] = useState<File[]>([]);
  const [fileUrls, setFileUrls] = useState<string[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // 所要時間が有効かどうかをチェックする関数
  const isDurationValid = () => {
    const hoursNum = parseInt(hours) || 0;
    const minutesNum = parseInt(minutes) || 0;
    return hoursNum > 0 || minutesNum > 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // データの検証
    if (!title.trim()) {
      alert('タイトルを入力してください');
      return;
    }
    
    // 所要時間のバリデーション
    if (!isDurationValid()) {
      alert('所要時間は時間か分のどちらかを1以上に設定してください');
      return;
    }
    
    // フォームデータの作成
    const formData: LocalEventFormData = {
      title,
      description,
      month: selectedMonth.toString(),
      category: (category === 'その他' ? otherCategory : category) as Category,
      age_groups: ageGroups,
      duration: `${hours}時間${minutes}分`,
      materials: materials,
      objectives: objectives,
      media_files: files,
    };
    
    console.log('送信する所要時間:', formData.duration);
    onSubmit(formData);
  };

  const handleAgeGroupChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value as AgeGroup;
    setAgeGroups(prev => 
      e.target.checked 
        ? [...prev, value]
        : prev.filter(group => group !== value)
    );
  };

  const handleMaterialsChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    // 複数の区切り文字（、・　）で分割し、空白を除去
    const items = e.target.value
      .split(/[、・\s]+/)
      .filter(item => item.trim() !== '');
    setMaterials(items);
  };

  const handleObjectivesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const items = e.target.value
      .split(/[、・\s]+/)
      .filter(item => item.trim() !== '');
    setObjectives(items);
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) {
      const newFiles = Array.from(e.target.files);
      setFiles(prev => [...prev, ...newFiles]);
    }
  };

  // ファイルが変更されたときにURLを作成
  useEffect(() => {
    const urls = files.map(file => URL.createObjectURL(file));
    setFileUrls(urls);
    
    // クリーンアップ関数
    return () => {
      urls.forEach(url => URL.revokeObjectURL(url));
    };
  }, [files]);

  const handleRemoveFile = (index: number) => {
    setFiles(prev => {
      const newFiles = [...prev];
      newFiles.splice(index, 1);
      return newFiles;
    });
    // URLの削除はuseEffectで自動的に行われるようになります
  };

  const renderPreview = (file: File, index: number) => {
    const isImage = file.type.startsWith('image/');
    const isVideo = file.type.startsWith('video/');
    const url = fileUrls[index];

    if (!url) return null;

    return (
      <div key={index} className={styles.previewItem}>
        {isImage && <img src={url} alt={`プレビュー ${index + 1}`} />}
        {isVideo && <video src={url} controls />}
        <button
          type="button"
          className={styles.removeButton}
          onClick={() => handleRemoveFile(index)}
        >
          ×
        </button>
      </div>
    );
  };

  return (
    <div className={styles.overlay} onClick={onCancel}>
      <div className={styles.content} onClick={e => e.stopPropagation()}>
        <h2 className={styles.title}>新しいイベントを追加</h2>
        <form onSubmit={handleSubmit} className={styles.form}>
          <div className={styles.formGroup}>
            <label>
              タイトル
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </label>
          </div>

          <div className={styles.formGroup}>
            <label>
              説明
              <textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                required
              />
            </label>
          </div>

          <div className={styles.formGroup}>
            <p>対象年齢</p>
            <div className={styles.checkboxGroup}>
              {AGE_GROUPS.map((age) => (
                <label
                  key={age}
                  className={`${styles.checkbox} ${ageGroups.includes(age) ? styles.selected : ''}`}
                  data-age={age}
                >
                  <input
                    type="checkbox"
                    value={age}
                    checked={ageGroups.includes(age)}
                    onChange={handleAgeGroupChange}
                  />
                  <span>{age}</span>
                </label>
              ))}
            </div>
          </div>

          <div className={styles.formGroup}>
            <p>カテゴリー</p>
            <div className={styles.radioGroup}>
              {CATEGORIES.map((cat) => (
                <label
                  key={cat}
                  className={`${styles.radioLabel} ${category === cat ? styles.selected : ''}`}
                  data-category={cat}
                >
                  <input
                    type="radio"
                    value={cat}
                    checked={category === cat}
                    onChange={(e) => setCategory(e.target.value as Category)}
                    className={styles.radioInput}
                    name="category"
                  />
                  <span>{cat}</span>
                </label>
              ))}
            </div>
            {category === 'その他' && (
              <input
                type="text"
                className={`${styles.otherInput} ${styles.visible}`}
                value={otherCategory}
                onChange={(e) => setOtherCategory(e.target.value)}
                placeholder="カテゴリーを入力してください"
                required={category === 'その他'}
              />
            )}
          </div>

          <div className={styles.formGroup}>
            <p>所要時間</p>
            <div className={styles.timeInputGroup}>
              <label>
                <input
                  type="number"
                  min="0"
                  max="24"
                  value={hours}
                  onChange={(e) => setHours(e.target.value)}
                  placeholder="0"
                />
                時間
              </label>
              <label>
                <input
                  type="number"
                  min="0"
                  max="59"
                  value={minutes}
                  onChange={(e) => setMinutes(e.target.value)}
                  placeholder="0"
                />
                分
              </label>
            </div>
          </div>

          <div className={styles.formGroup}>
            <label>
              準備物
              <textarea
                value={materials.join('、')}
                onChange={handleMaterialsChange}
                placeholder="例：画用紙、クレヨン、はさみ"
                rows={3}
                style={{ resize: 'vertical' }}
              />
            </label>
          </div>

          <div className={styles.formGroup}>
            <label>
              目的
              <textarea
                value={objectives.join('、')}
                onChange={handleObjectivesChange}
                placeholder="例：創造性を育む、手先の器用さを養う、集中力を高める"
                rows={3}
                style={{ resize: 'vertical' }}
              />
            </label>
          </div>

          <div className={styles.optionalSection}>
            <h3 className={styles.optionalTitle}>画像・動画（任意）</h3>
            <div className={styles.uploadArea}>
              <p>クリックして画像・動画をアップロード</p>
              <input
                type="file"
                multiple
                onChange={handleFileChange}
                ref={fileInputRef}
                className={styles.fileInput}
                accept="image/*,video/*"
              />
            </div>
            {files.length > 0 && (
              <div className={styles.previewArea}>
                {files.map((file, index) => renderPreview(file, index))}
              </div>
            )}
          </div>

          <div className={styles.buttonGroup}>
            <button type="button" onClick={onCancel} className={styles.cancelButton}>
              キャンセル
            </button>
            <button type="submit" className={styles.submitButton}>
              追加
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="app/components/EditEventForm.tsx">
'use client';

import React, { useState, useRef, ChangeEvent, useEffect } from 'react';
import styles from './EditEventForm.module.css';
import type { Event, LocalEventFormData, MediaFile, Category, AgeGroup, EventFormData, Duration } from '../types/event';

export const CATEGORIES = ['壁　面', '制作物', 'その他'] as const;
export const AGE_GROUPS = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'] as const;
const MONTHS = Array.from({ length: 12 }, (_, i) => String(i + 1));

// EventFormDataを拡張して実際のファイルを含むことができるようにします
type EditFormData = Omit<EventFormData, 'media_files'> & {
  media_files: (MediaFile | File)[];
};

interface Props {
  data: Omit<Event, 'id' | 'views' | 'created_at' | 'updated_at' | 'user_id' | 'isOwner' | 'profiles'>;
  onSubmit: (data: EditFormData) => Promise<void>;
  onCancel: () => void;
}

export default function EditEventForm({ data, onSubmit, onCancel }: Props) {
  const [formData, setFormData] = useState<EditFormData>({
    title: data.title,
    description: data.description,
    month: data.month,
    date: data.date,
    duration: data.duration,
    age_groups: data.age_groups,
    category: data.category,
    materials: data.materials,
    objectives: data.objectives,
    media_files: []
  });
  
  const [otherCategory, setOtherCategory] = useState('');
  const [hours, setHours] = useState('0');
  const [minutes, setMinutes] = useState('0');
  const fileInputRef = useRef<HTMLInputElement>(null);

  // コンポーネントが初期化されるときにdurationから時間と分を抽出
  useEffect(() => {
    if (data.duration) {
      // オブジェクト形式の場合
      if (typeof data.duration === 'object' && data.duration.end) {
        const timeMatch = data.duration.end.match(/^(\d{1,2}):(\d{1,2})$/);
        if (timeMatch) {
          setHours(timeMatch[1]);
          setMinutes(timeMatch[2]);
        }
      } 
      // 文字列形式の場合（例: "2時間30分"）
      else if (typeof data.duration === 'string') {
        const durationStr = data.duration as string;
        const hoursMatch = durationStr.match(/(\d+)時間/);
        const minutesMatch = durationStr.match(/(\d+)分/);
        
        if (hoursMatch) setHours(hoursMatch[1]);
        if (minutesMatch) setMinutes(minutesMatch[1]);
      }
    }
  }, [data.duration]);

  const isDurationValid = () => {
    const hoursNum = parseInt(hours) || 0;
    const minutesNum = parseInt(minutes) || 0;
    return hoursNum > 0 || minutesNum > 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!isDurationValid()) {
      alert('所要時間を入力してください');
      return;
    }
    
    // 所要時間を文字列形式で保存（"X時間Y分"形式）
    const hoursNum = parseInt(hours) || 0;
    const minutesNum = parseInt(minutes) || 0;
    let durationStr = '';
    
    if (hoursNum > 0) {
      durationStr += `${hoursNum}時間`;
    }
    
    if (minutesNum > 0) {
      durationStr += `${minutesNum}分`;
    }
    
    const finalCategory = formData.category === 'その他' ? otherCategory : formData.category;
    const formDataToSubmit: EditFormData = {
      ...formData,
      duration: {
        start: "00:00",
        end: `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`
      },
      category: finalCategory as Category,
      media_files: formData.media_files
    };
    await onSubmit(formDataToSubmit);
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData((prev: EditFormData) => ({
      ...prev,
      [name]: value
    }));
  };

  const handleAgeGroupChange = (group: AgeGroup) => {
    setFormData((prev: EditFormData) => {
      const newAgeGroups = prev.age_groups.includes(group)
        ? prev.age_groups.filter(g => g !== group)
        : [...prev.age_groups, group];
      return {
        ...prev,
        age_groups: newAgeGroups
      };
    });
  };

  const handleCategoryChange = (category: Category) => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      category
    }));
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) {
      const newFiles = Array.from(e.target.files);
      const newMediaFiles = newFiles.map(file => {
        const type = file.type.startsWith('image/') ? 'image' : 'video';
        return {
          type: type as 'image' | 'video',
          url: URL.createObjectURL(file),
          file: file // 元のFileオブジェクトを保持
        };
      });
      
      setFormData(prev => ({
        ...prev,
        media_files: [...prev.media_files, ...newMediaFiles]
      }));
    }
  };

  const handleRemoveFile = (index: number) => {
    setFormData(prev => {
      const newMediaFiles = [...prev.media_files];
      newMediaFiles.splice(index, 1);
      return {
        ...prev,
        media_files: newMediaFiles
      };
    });
  };

  const renderPreview = (file: MediaFile | File, index: number) => {
    // Fileオブジェクトの場合はURL.createObjectURLを使用
    if (file instanceof File) {
      const isImage = file.type.startsWith('image/');
      const isVideo = file.type.startsWith('video/');
      const url = URL.createObjectURL(file);

      return (
        <div key={index} className={styles.previewItem}>
          {isImage && <img src={url} alt={`プレビュー ${index + 1}`} />}
          {isVideo && <video src={url} controls />}
          <button
            type="button"
            className={styles.removeButton}
            onClick={() => handleRemoveFile(index)}
          >
            ×
          </button>
        </div>
      );
    }

    // MediaFileオブジェクトの場合
    return (
      <div key={index} className={styles.previewItem}>
        {file.type === 'image' && <img src={file.url} alt={`プレビュー ${index + 1}`} />}
        {file.type === 'video' && <video src={file.url} controls />}
        <button
          type="button"
          className={styles.removeButton}
          onClick={() => handleRemoveFile(index)}
        >
          ×
        </button>
      </div>
    );
  };

  const handleArrayFieldChange = (e: React.KeyboardEvent<HTMLInputElement>, field: keyof Pick<Event, 'materials' | 'objectives'>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const value = e.currentTarget.value.trim();
      if (value) {
        setFormData((prev: EditFormData) => ({
          ...prev,
          [field]: [...prev[field], value],
        }));
        e.currentTarget.value = '';
      }
    }
  };

  const removeArrayItem = (field: keyof Pick<Event, 'materials' | 'objectives'>, index: number) => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      [field]: prev[field].filter((_, i) => i !== index),
    }));
  };

  const handleMaterialChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const items = e.target.value
      .split(/\n/)
      .map(item => item.trim())
      .filter(item => item !== '');
    setFormData(prev => ({
      ...prev,
      materials: items
    }));
  };

  const handleObjectiveChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const items = e.target.value
      .split(/\n/)
      .map(item => item.trim())
      .filter(item => item !== '');
    setFormData(prev => ({
      ...prev,
      objectives: items
    }));
  };

  const addMaterial = () => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      materials: [...prev.materials, '']
    }));
  };

  const addObjective = () => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      objectives: [...prev.objectives, '']
    }));
  };

  const removeMaterial = (index: number) => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      materials: prev.materials.filter((_, i) => i !== index)
    }));
  };

  const removeObjective = (index: number) => {
    setFormData((prev: EditFormData) => ({
      ...prev,
      objectives: prev.objectives.filter((_, i) => i !== index)
    }));
  };

  return (
    <div className={styles.overlay} onClick={onCancel}>
      <div className={styles.content} onClick={e => e.stopPropagation()}>
        <h2 className={styles.title}>イベントを編集</h2>
        <form onSubmit={handleSubmit} className={styles.form}>
          <div className={styles.formGroup}>
            <label>
              月
              <select
                name="month"
                value={formData.month}
                onChange={handleChange}
                required
                className={styles.select}
              >
                {MONTHS.map((month) => (
                  <option key={month} value={month}>
                    {month}月
                  </option>
                ))}
              </select>
            </label>
          </div>

          <div className={styles.formGroup}>
            <label>
              タイトル
              <input
                type="text"
                name="title"
                value={formData.title}
                onChange={handleChange}
                required
                className={`${styles.input} ${styles.fullWidth}`}
              />
            </label>
          </div>

          <div className={styles.formGroup}>
            <label>
              説明
              <textarea
                name="description"
                value={formData.description}
                onChange={handleChange}
                required
                className={`${styles.textarea} ${styles.fullWidth}`}
              />
            </label>
          </div>

          <div className={styles.formGroup}>
            <label htmlFor="materials">準備物（・ や 、 で区切って入力）</label>
            <textarea
              id="materials"
              name="materials"
              value={formData.materials.join('、')}
              onChange={(e) => {
                const items = e.target.value
                  .split(/[、・]/)
                  .map(item => item.trim())
                  .filter(item => item !== '');
                setFormData(prev => ({
                  ...prev,
                  materials: items
                }));
              }}
              placeholder="例：&#13;&#10;画用紙、クレヨン、はさみ"
              className={`${styles.textarea} ${styles.fullWidth}`}
              rows={5}
            />
          </div>

          <div className={styles.formGroup}>
            <label htmlFor="objectives">目的（・ や 、 で区切って入力）</label>
            <textarea
              id="objectives"
              name="objectives"
              value={formData.objectives.join('、')}
              onChange={(e) => {
                const items = e.target.value
                  .split(/[、・]/)
                  .map(item => item.trim())
                  .filter(item => item !== '');
                setFormData(prev => ({
                  ...prev,
                  objectives: items
                }));
              }}
              placeholder="例：&#13;&#10;創造性を育む、手先の器用さを養う、集中力を高める"
              className={`${styles.textarea} ${styles.fullWidth}`}
              rows={5}
            />
          </div>

          <div className={styles.formGroup}>
            <label>対象年齢</label>
            <div className={styles.checkboxGroup}>
              {AGE_GROUPS.map((age) => (
                <label
                  key={age}
                  className={`${styles.checkbox} ${formData.age_groups.includes(age) ? styles.selected : ''}`}
                  data-age={age}
                >
                  <input
                    type="checkbox"
                    checked={formData.age_groups.includes(age)}
                    onChange={() => handleAgeGroupChange(age)}
                  />
                  {age}
                </label>
              ))}
            </div>
          </div>

          <div className={styles.formGroup}>
            <label>カテゴリー</label>
            <div className={styles.radioGroup}>
              {CATEGORIES.map((cat) => (
                <label
                  key={cat}
                  className={`${styles.radioLabel} ${formData.category === cat ? styles.selected : ''}`}
                  data-category={cat}
                >
                  <input
                    type="radio"
                    name="category"
                    value={cat}
                    checked={formData.category === cat}
                    onChange={(e) => handleCategoryChange(e.target.value as Category)}
                  />
                  {cat}
                </label>
              ))}
            </div>
            {formData.category === 'その他' && (
              <input
                type="text"
                className={`${styles.otherInput} ${styles.visible}`}
                value={otherCategory}
                onChange={(e) => setOtherCategory(e.target.value)}
                placeholder="カテゴリーを入力してください"
                required={formData.category === 'その他'}
              />
            )}
          </div>

          <div className={styles.formGroup}>
            <label>所要時間</label>
            <div className={styles.timeInputGroup}>
              <input
                type="number"
                min="0"
                max="24"
                value={hours}
                onChange={(e) => setHours(e.target.value)}
                placeholder="0"
                className={styles.timeInput}
              />
              <span>時間</span>
              <input
                type="number"
                min="0"
                max="59"
                value={minutes}
                onChange={(e) => setMinutes(e.target.value)}
                placeholder="0"
                className={styles.timeInput}
              />
              <span>分</span>
            </div>
          </div>

          <div className={styles.optionalSection}>
            <h3 className={styles.optionalTitle}>画像・動画</h3>
            <div
              className={styles.uploadArea}
              onClick={() => fileInputRef.current?.click()}
            >
              <input
                type="file"
                ref={fileInputRef}
                className={styles.uploadInput}
                onChange={handleFileChange}
                accept="image/*,video/*"
                multiple
              />
              <p>クリックして画像・動画を追加</p>
            </div>

            {formData.media_files.length > 0 && (
              <div className={styles.previewArea}>
                {formData.media_files.map((file, index) => renderPreview(file, index))}
              </div>
            )}
          </div>

          <div className={styles.buttonGroup}>
            <button type="button" onClick={onCancel} className={styles.cancelButton}>
              キャンセル
            </button>
            <button type="submit" className={styles.submitButton}>
              更新
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="package.json">
{
  "name": "childcare-event-ideas",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@shadcn/ui": "^0.0.4",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.6.1",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "next": "^14.2.28",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@supabase/supabase-js": "^2.49.4",
    "autoprefixer": "^10.4.17",
    "dotenv": "^16.5.0",
    "postcss": "^8.4.35",
    "postcss-nesting": "^12.0.2",
    "tailwindcss": "^3.4.1",
    "ts-node": "^10.9.2",
    "uuid": "^11.1.0"
  }
}
</file>

<file path="app/events/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';
import Link from 'next/link';
import styles from './page.module.css';
import { Event, AgeGroup, EventFormData, LocalEventFormData, Category, MediaFile, Duration } from '../types/event';
import EventOverlay from '../components/EventOverlay';
import EditEventForm from '../components/EditEventForm';
import Image from 'next/image';

// 編集フォームからのデータを受け取るための型
type EditFormData = Omit<EventFormData, 'media_files'> & {
  media_files: (MediaFile | File)[];
};

const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// 季節を判定する関数
const getSeason = (month: number) => {
  if (month >= 3 && month <= 5) return 'spring';
  if (month >= 6 && month <= 8) return 'summer';
  if (month >= 9 && month <= 11) return 'autumn';
  return 'winter';
};

// 年齢グループの定義
const AGE_GROUPS = ['0歳児', '1歳児', '2歳児', '3歳児', '4歳児', '5歳児'];

// カテゴリーのスタイルを取得する関数
const getCategoryStyle = (category: string) => {
  switch (category) {
    case '壁　面':
    return styles.categoryWall;
    case '制作物':
    return styles.categoryArt;
    default:
  return styles.categoryOther;
  }
};

// 年齢グループのスタイルを取得する関数
const getAgeGroupStyle = (age: string) => {
  switch (age) {
    case '0歳児':
      return styles.age0;
    case '1歳児':
      return styles.age1;
    case '2歳児':
      return styles.age2;
    case '3歳児':
      return styles.age3;
    case '4歳児':
      return styles.age4;
    case '5歳児':
      return styles.age5;
    default:
      return styles.ageAll;
  }
};

// カテゴリーの表示テキストを取得する関数
const getCategoryDisplayText = (category: string) => {
  if (category !== '壁　面' && category !== '制作物') {
  return 'その他';
  }
  return category;
};

const getMonthClass = (month: number) => {
  return styles[`month${month}`];
};

// 所要時間をフォーマットする関数
const formatDuration = (duration: { start?: string, end?: string } | string | null | undefined) => {
  // 値が存在しない場合
  if (!duration) return '不明';
  
  // 文字列の場合はJSONとしてパース
  if (typeof duration === 'string') {
    try {
      const parsedDuration = JSON.parse(duration);
      return formatDuration(parsedDuration);
    } catch (e) {
      // 時間と分を抽出（例: "2時間30分"）
      const durationStr = duration as string;
      const hoursMatch = durationStr.match(/(\d+)時間/);
      const minutesMatch = durationStr.match(/(\d+)分/);
      
      if (hoursMatch || minutesMatch) {
        const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
        const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
        
        if (hours > 0 && minutes > 0) {
          return `${hours}時間${minutes}分`;
        } else if (hours > 0) {
          return `${hours}時間`;
        } else if (minutes > 0) {
          return `${minutes}分`;
        }
      }
      return durationStr;
    }
  }
  
  // オブジェクトの場合はend値を使う
  const durationObj = duration as { start?: string, end?: string };
  const end = durationObj.end;
  if (!end) return '不明';
  
  // HH:MM形式の場合
  const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1]);
    const minutes = parseInt(timeMatch[2]);
    
    if (hours > 0 && minutes > 0) {
      return `${hours}時間${minutes}分`;
    } else if (hours > 0) {
      return `${hours}時間`;
    } else if (minutes > 0) {
      return `${minutes}分`;
    }
  }
  
  return end;
};

const EventCard = ({ event, onEventClick }: { event: Event; onEventClick: (event: Event) => void }) => {
  return (
    <div
      className="bg-white rounded-lg shadow-md overflow-hidden cursor-pointer hover:shadow-lg transition-shadow"
      onClick={() => onEventClick(event)}
    >
      {/* 画像を上部に表示 */}
      <div className="relative w-full h-48">
        {event.media_files && event.media_files.length > 0 ? (
          event.media_files[0].type === 'video' ? (
            <video
              src={event.media_files[0].url}
              className="w-full h-full object-cover"
              controls
            />
          ) : (
            <Image
              src={event.media_files[0].url}
              alt={event.title}
              className="w-full h-full object-cover"
              width={400}
              height={300}
            />
          )
        ) : (
          <div className="w-full h-full bg-gray-200 flex items-center justify-center">
            <span className="text-gray-400">No image</span>
          </div>
        )}
      </div>

      <div className="p-4">
        <h3 className="text-xl font-semibold mb-2">{event.title}</h3>
        <p className="text-gray-600 mb-2">{event.description}</p>
        
        <div className="flex flex-wrap gap-2 mb-2">
          {[...event.age_groups].sort().map((age) => (
            <span
              key={age}
              className={`px-2 py-1 rounded-full text-sm ${getAgeGroupStyle(age)}`}
            >
              {age}
            </span>
          ))}
        </div>

        <div className="flex items-center gap-2">
          <span className={`px-2 py-1 rounded-full text-sm ${getCategoryStyle(event.category)}`}>
            {event.category}
          </span>
          <span className="text-gray-500 text-sm">{event.month}月</span>
        </div>
      </div>
    </div>
  );
};

export default function EventListPage() {
  const [events, setEvents] = useState<Event[]>([]);
  const [filteredEvents, setFilteredEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [showAdvancedSearch, setShowAdvancedSearch] = useState(false);
  const [sortType, setSortType] = useState<'date' | 'popular'>('date');
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  const [isOverlayOpen, setIsOverlayOpen] = useState(false);
  const [editingEvent, setEditingEvent] = useState<Event | null>(null);
  const [advancedFilters, setAdvancedFilters] = useState({
    title: '',
    description: '',
    category: '',
    ageGroups: [] as string[],
    duration: '',
    materials: [] as string[],
    objectives: [] as string[],
    hasImage: false,
    hasVideo: false
  });
  const router = useRouter();

  const fetchEvents = async () => {
    try {
    setLoading(true);

      // セッションの確認
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();

      if (sessionError) {
        setError('セッションの取得に失敗しました');
        return;
      }

      if (!session) {
        router.push('/');
        return;
      }

      // イベントデータの取得
      const { data: eventsData, error: eventsError } = await supabase
        .from('events')
        .select(`
          *,
          profiles (
            name
          )
        `)
        .order('created_at', { ascending: false });

      if (eventsError) {
        setError('イベントの取得中に予期せぬエラーが発生しました');
        return;
      }

      if (eventsData) {
        // イベントデータを処理
        const processedEvents = eventsData.map(event => {
          let eventDuration = event.duration;

          // null/undefined チェック
          if (!eventDuration) {
            return {
              ...event,
              isOwner: event.user_id === session.user.id,
              profiles: event.profiles || null,
              duration: { start: '00:00', end: '00:00' }
            };
          }

          // 文字列の場合
          if (typeof eventDuration === 'string') {
            // JSONかどうか判断（{で始まる場合のみパース試行）
            if (eventDuration.trim().startsWith('{')) {
              try {
                eventDuration = JSON.parse(eventDuration);
              } catch (e) {
                // JSONパースに失敗した場合は時間文字列として処理
                const durationStr = eventDuration as string;
                const hoursMatch = durationStr.match(/(\d+)時間/);
                const minutesMatch = durationStr.match(/(\d+)分/);
                
                const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                
                // 時間が取得できた場合
                if (hours > 0 || minutes > 0) {
                  if (hours > 0 && minutes > 0) {
                    eventDuration = `${hours}時間${minutes}分`;
                  } else if (hours > 0) {
                    eventDuration = `${hours}時間`;
                  } else if (minutes > 0) {
                    eventDuration = `${minutes}分`;
                  }
                } else {
                  // 時間が取得できなかった場合はデフォルト値
                  eventDuration = { start: '00:00', end: '00:00' };
                }
              }
            } else {
              // JSONではない通常の時間文字列
              const durationStr = eventDuration as string;
              const hoursMatch = durationStr.match(/(\d+)時間/);
              const minutesMatch = durationStr.match(/(\d+)分/);
              
              const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
              const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
              
              // 時間が取得できなかった場合はデフォルト値
              if (hours === 0 && minutes === 0) {
                eventDuration = { start: '00:00', end: '00:00' };
              }
            }
          }
          
          // オブジェクトの場合、必要なフィールドの存在を確認
          if (typeof eventDuration === 'object' && (!('start' in eventDuration) || !('end' in eventDuration) || !eventDuration.start || !eventDuration.end)) {
            eventDuration = { start: '00:00', end: '00:00' };
          }

          return {
        ...event,
            isOwner: event.user_id === session.user.id,
            profiles: event.profiles || null,
            duration: eventDuration
          };
        });

      setEvents(processedEvents);
      } else {
        setEvents([]);
      }
    } catch (error) {
      console.error('予期せぬエラー:', error);
      setError('イベントの取得中に予期せぬエラーが発生しました');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  // イベントが更新されたときにイベント一覧を再取得する
  useEffect(() => {
    if (selectedEvent) {
    const channel = supabase
        .channel('events_changes')
      .on('postgres_changes', 
        { 
            event: 'UPDATE', 
          schema: 'public', 
            table: 'events',
            filter: `id=eq.${selectedEvent.id}`
        }, 
          () => {
          fetchEvents();
        }
      )
        .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
    }
  }, [selectedEvent]);

  // 現在の月を取得
  const currentMonth = new Date().getMonth() + 1; // JavaScriptの月は0から始まるため+1

  // 月の比較関数（現在の月からの距離を計算）
  const getMonthDistance = (month: number) => {
    const diff = month - currentMonth;
    return diff >= 0 ? diff : diff + 12;
  };

  // 検索機能とソート機能を実装
  useEffect(() => {
    if (events.length === 0) return;

    let filtered = [...events];

    // 基本的な検索（タイトルと説明文）
    if (searchTerm) {
      const query = searchTerm.toLowerCase();
      filtered = filtered.filter(event => 
        event.title?.toLowerCase().includes(query) || 
        event.description?.toLowerCase().includes(query) ||
        event.category?.toLowerCase().includes(query)
      );
    }

    // 詳細検索フィルター
    if (showAdvancedSearch) {
      // タイトル
      if (advancedFilters.title) {
        const titleQuery = advancedFilters.title.toLowerCase();
        filtered = filtered.filter(event => 
          event.title?.toLowerCase().includes(titleQuery)
        );
      }

      // 説明文
      if (advancedFilters.description) {
        const descQuery = advancedFilters.description.toLowerCase();
        filtered = filtered.filter(event => 
          event.description?.toLowerCase().includes(descQuery)
        );
      }

      // 年齢グループ
      if (advancedFilters.ageGroups.length > 0) {
        filtered = filtered.filter(event => {
          if (!event.age_groups || !Array.isArray(event.age_groups)) return false;
          return advancedFilters.ageGroups.some(age => event.age_groups.includes(age as AgeGroup));
        });
      }

      // カテゴリー
      if (advancedFilters.category) {
        filtered = filtered.filter(event => {
          const eventCategory = event.category || 'その他';
          return eventCategory === advancedFilters.category;
        });
      }

      // 所要時間
      if (advancedFilters.duration) {
        filtered = filtered.filter(event => {
          // durationがない場合はフィルタリングから除外
          if (!event.duration) return false;
          
          let durationStr = '';
          
          // durationが文字列の場合
          if (typeof event.duration === 'string') {
            try {
              // JSONとして解析を試みる
              const parsedDuration = JSON.parse(event.duration);
              if (parsedDuration && typeof parsedDuration === 'object' && parsedDuration.start && parsedDuration.end) {
                durationStr = `${parsedDuration.start}～${parsedDuration.end}`;
              } else {
                // 解析できたが適切なプロパティがない場合は元の文字列を使用
                durationStr = event.duration;
              }
            } catch (e) {
              // JSON解析に失敗した場合は元の文字列を使用
              durationStr = event.duration;
            }
          } 
          // durationがオブジェクトの場合
          else if (typeof event.duration === 'object' && event.duration !== null) {
            if (event.duration.start && event.duration.end) {
              durationStr = `${event.duration.start}～${event.duration.end}`;
            }
          }
          
          return durationStr.toLowerCase().includes(advancedFilters.duration.toLowerCase());
        });
      }

      // 準備物
      if (advancedFilters.materials.length > 0) {
        filtered = filtered.filter(event => {
          if (!event.materials || !Array.isArray(event.materials)) return false;
          return advancedFilters.materials.every(material => 
            event.materials.some(m => m.includes(material))
          );
        });
      }

      // 目的
      if (advancedFilters.objectives.length > 0) {
        filtered = filtered.filter(event => {
          if (!event.objectives || !Array.isArray(event.objectives)) return false;
          return advancedFilters.objectives.every(objective => 
            event.objectives.some(o => o.includes(objective))
          );
        });
      }

      // 画像あり
      if (advancedFilters.hasImage) {
        filtered = filtered.filter(event => 
          event.media_files && event.media_files.some(file => 
            file.type.startsWith('image/')
          )
        );
      }

      // 動画あり
      if (advancedFilters.hasVideo) {
      filtered = filtered.filter(event => 
          event.media_files && event.media_files.some(file => 
            file.type.startsWith('video/')
          )
        );
      }
    }

    // 並び替え
    if (sortType === 'date') {
      filtered.sort((a, b) => {
        // 月を数値として比較
        const monthA = Number(a.month);
        const monthB = Number(b.month);
        
        if (monthA !== monthB) {
          return monthA - monthB;
        }
        
        // 月が同じ場合は作成日時で比較
        const dateA = new Date(a.created_at || 0).getTime();
        const dateB = new Date(b.created_at || 0).getTime();
        return dateB - dateA;
      });
    } else if (sortType === 'popular') {
      filtered.sort((a, b) => {
        const viewsA = a.views || 0;
        const viewsB = b.views || 0;
        if (viewsA !== viewsB) {
          return viewsB - viewsA;
        }
        // 閲覧数が同じ場合は作成日時で比較
        const dateA = new Date(a.created_at || 0).getTime();
        const dateB = new Date(b.created_at || 0).getTime();
        return dateB - dateA;
      });
    }

    setFilteredEvents(filtered);
  }, [events, searchTerm, showAdvancedSearch, advancedFilters, sortType, currentMonth]);

  // 検索クエリの変更を処理
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    // 検索は自動的に実行されるため、フォームのデフォルトの送信を防ぐだけ
  };

  // 詳細検索モーダルを開く
  const openAdvancedSearch = () => {
    setShowAdvancedSearch(true);
  };

  // 詳細検索モーダルを閉じる
  const closeAdvancedSearch = () => {
    setShowAdvancedSearch(false);
  };

  // 詳細検索フィルターをリセット
  const resetAdvancedFilters = () => {
    setAdvancedFilters({
      title: '',
      description: '',
      category: '',
      ageGroups: [],
      duration: '',
      materials: [],
      objectives: [],
      hasImage: false,
      hasVideo: false
    });
  };

  // 詳細検索フィルターを適用
  const applyAdvancedFilters = () => {
    // 検索は自動的に実行されるため、モーダルを閉じるだけ
    setShowAdvancedSearch(false);
  };

  const handleEventClick = async (event: Event) => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        throw new Error('認証されていません');
      }

      // イベントの閲覧数を更新
      const { error, data } = await supabase
        .from('events')
        .update({ views: (event.views || 0) + 1 })
        .eq('id', event.id)
        .select(`
          *,
          profiles (
            name
          )
        `);

      if (error) throw error;

      if (data && data.length > 0) {
        // durationの処理
        let eventDuration = data[0].duration;
        if (typeof eventDuration === 'string') {
          try {
            eventDuration = JSON.parse(eventDuration);
          } catch (e) {
            // 文字列形式の処理（例: "2時間30分"）
            const durationStr = eventDuration as string;
            const hoursMatch = durationStr.match(/(\d+)時間/);
            const minutesMatch = durationStr.match(/(\d+)分/);
            
            const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
            const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
            
            // 直接表示用の形式に変換
            if (hours > 0 && minutes > 0) {
              eventDuration = `${hours}時間${minutes}分`;
            } else if (hours > 0) {
              eventDuration = `${hours}時間`;
            } else if (minutes > 0) {
              eventDuration = `${minutes}分`;
            } else {
              eventDuration = { start: '00:00', end: '00:00' };
            }
          }
        }
        
        // 空のオブジェクトかnullの場合
        if (!eventDuration) {
          eventDuration = { start: '00:00', end: '00:00' };
        }
        
        // オブジェクトだが必要なフィールドがない場合
        if (typeof eventDuration === 'object' && (!('start' in eventDuration) || !('end' in eventDuration) || !eventDuration.start || !eventDuration.end)) {
          eventDuration = { start: '00:00', end: '00:00' };
        }
        
        // データを加工
        const updatedEvent = {
          ...data[0],
          category: (data[0].category || 'その他') as Category,
          age_groups: (data[0].age_groups || []) as AgeGroup[],
          media_files: (data[0].media_files || []).map((file: { type: string; url: string }) => ({
            type: file.type,
            url: file.url
          })) as MediaFile[],
          views: data[0].views || 0,
          isOwner: data[0].user_id === session.user.id,
          profiles: data[0].profiles || null,
          duration: eventDuration
        };
        
        // 更新されたイベントをステートに設定
        setSelectedEvent(updatedEvent);
        setIsOverlayOpen(true);
      } else {
        // データがない場合は既存のイベントを使用
    setSelectedEvent(event);
        setIsOverlayOpen(true);
      }
    } catch (error) {
      console.error('イベントの更新中にエラーが発生しました:', error);
      // エラーが発生しても表示はする
      setSelectedEvent(event);
      setIsOverlayOpen(true);
    }
  };

  const handleEventDelete = async (id: string) => {
    try {
      const { error } = await supabase
        .from('events')
        .delete()
        .eq('id', id);

      if (error) throw error;

      setEvents(events.filter(event => event.id !== id));
      setSelectedEvent(null);
    } catch (error) {
      console.error('Error deleting event:', error);
      setError('イベントの削除に失敗しました');
    }
  };

  const handleEventEdit = () => {
    if (selectedEvent) {
      setEditingEvent(selectedEvent);
    }
  };

  const handleEditEventSubmit = async (formData: EditFormData) => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        throw new Error('認証されていません');
      }

      if (!editingEvent) {
        throw new Error('編集するイベントが選択されていません');
      }

      // media_filesの中からFileオブジェクトだけを抽出
      const files = formData.media_files.filter(file => file instanceof File) as File[];
      const existingMediaFiles = formData.media_files.filter(file => !(file instanceof File) && !('file' in file)) as MediaFile[];
      
      // ファイルサイズの制限（5MB）
      const MAX_FILE_SIZE = 5 * 1024 * 1024;

      // 新しいファイルをアップロード
      const newMediaFiles = await Promise.all(
        files.map(async (file: File) => {
          try {
            console.log('処理中のファイル:', file.name, file.type, file.size);

            // ファイルサイズのチェック
            if (file.size > MAX_FILE_SIZE) {
              throw new Error(`ファイル ${file.name} が大きすぎます。5MB以下のファイルを選択してください。`);
            }

            // 許可されるファイルタイプ
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
            if (!allowedTypes.includes(file.type)) {
              throw new Error(`ファイル ${file.name} の形式がサポートされていません。`);
            }

            // ファイル名を一意にする
            const fileExt = file.name.split('.').pop();
            const fileName = `${session.user.id}/${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
            
            console.log('アップロード前のファイル名:', fileName);

            // ファイルをストレージにアップロード
            const { data: uploadData, error: uploadError } = await supabase.storage
              .from('event-media')
              .upload(fileName, file, {
                cacheControl: '3600',
                upsert: false
              });

            if (uploadError) {
              console.error('ファイルアップロードエラー:', uploadError);
              throw uploadError;
            }

            console.log('アップロード成功:', uploadData);

            // アップロードしたファイルのURLを取得
            const { data: { publicUrl } } = supabase.storage
              .from('event-media')
              .getPublicUrl(fileName);

            console.log('取得したパブリックURL:', publicUrl);

            // ファイルタイプを判断
            const type = file.type.startsWith('image/') ? 'image' : 'video';
            
            return {
              type,
              url: publicUrl
            } as MediaFile;
          } catch (error) {
            console.error('ファイル処理エラー:', error);
            throw error;
          }
        })
      );

      // 既存のメディアファイルと新しくアップロードしたファイルを結合
      const allMediaFiles = [...existingMediaFiles, ...newMediaFiles];

      // durationが文字列の場合はそのまま使用
      // durationがオブジェクトの場合は文字列に変換
      let durationStr = '';
      if (typeof formData.duration === 'object') {
        const end = formData.duration.end;
        if (end) {
          const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            
            if (hours > 0) {
              durationStr += `${hours}時間`;
            }
            
            if (minutes > 0) {
              durationStr += `${minutes}分`;
            }
          }
        }
    } else {
        durationStr = formData.duration;
      }
      
      const { data, error } = await supabase
        .from('events')
        .update({
          title: formData.title,
          description: formData.description,
          category: formData.category,
          month: formData.month,
          date: formData.date,
          age_groups: formData.age_groups,
          duration: durationStr || '不明',
          materials: formData.materials,
          objectives: formData.objectives,
          media_files: allMediaFiles,
          updated_at: new Date().toISOString()
        })
        .eq('id', editingEvent.id)
        .select();
        
      if (error) {
        console.error('イベント更新エラー:', error);
        alert('イベントの更新に失敗しました: ' + error.message);
        return;
      }

      if (data) {
        console.log('更新されたイベント:', data);
        await fetchEvents();
      }
      setEditingEvent(null);
      setSelectedEvent(null);
    } catch (error) {
      console.error('Error:', error);
      alert(error instanceof Error ? error.message : 'ファイルのアップロード中にエラーが発生しました');
    }
  };

  const handleEditCancel = () => {
    if (window.confirm('編集をキャンセルしてもよろしいですか？')) {
      setEditingEvent(null);
    }
  };

  // モーダルの外側クリック時の処理を追加
  const handleModalOverlayClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      handleEditCancel();
    }
  };

  const handleLogout = () => {
    try {
      // すべてのクッキーを削除
      document.cookie.split(";").forEach(c => {
        const key = c.trim().split("=")[0];
        if (key) {
          document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        }
      });
      
      // Supabase関連のローカルストレージをクリア
      localStorage.removeItem('supabase.auth.token');
      localStorage.removeItem('supabase.auth.expires_at');
      localStorage.removeItem('supabase.auth.refresh_token');
      
      // ページをリロード
      window.location.href = '/';
    } catch (error) {
      console.error('ログアウト処理エラー:', error);
      // エラーが発生しても強制的にホームページへ
      window.location.href = '/';
    }
  };

  // 並び替え処理を行う関数
  const handleSort = (type: 'date' | 'popular') => {
    setSortType(type);
    const sorted = [...events].sort((a, b) => {
      if (type === 'date') {
        const dateA = a.created_at ? new Date(a.created_at).getTime() : Date.now();
        const dateB = b.created_at ? new Date(b.created_at).getTime() : Date.now();
        return dateB - dateA;
          } else {
        // 人気順（閲覧数で降順）
        const viewsA = a.views || 0;
        const viewsB = b.views || 0;
        if (viewsA !== viewsB) {
          return viewsB - viewsA;
        }
        // 閲覧数が同じ場合は作成日時で比較
        const dateA = new Date(a.created_at || 0).getTime();
        const dateB = new Date(b.created_at || 0).getTime();
        return dateB - dateA;
      }
    });
    setFilteredEvents(sorted);
  };

  // イベントカードのレンダリング部分を修正
  const renderEventCard = (event: Event) => (
    <div 
      key={event.id} 
      className={`${styles.eventCard} ${styles[getSeason(parseInt(event.month))]}`}
      onClick={() => handleEventClick(event)}
    >
      <div className={styles.eventCardHeader}>
        <div className={`${styles.eventCategory} ${getCategoryStyle(event.category)}`}>
          {getCategoryDisplayText(event.category)}
        </div>
        <div className={styles.eventMonth}>
          {event.month}月
        </div>
      </div>
      
      <h3 className={styles.eventTitle}>{event.title}</h3>
      
      <div className={styles.eventThumb}>
        {event.media_files && event.media_files.length > 0 &&
          event.media_files.some(file => file.type === 'image') &&
          event.media_files.find(file => file.type === 'image')?.url ? (
          <Image
            src={event.media_files.find(file => file.type === 'image')!.url}
            alt={event.title}
            width={300}
            height={200}
            className={styles.eventImage}
          />
        ) : (
          <div className={styles.noImage}>
            <span>No Image</span>
          </div>
        )}
      </div>
      
      <div className={styles.eventMeta}>
        <div className={styles.ageGroups}>
          {event.age_groups.map(age => (
            <span key={age} className={`${styles.ageGroup} ${getAgeGroupStyle(age)}`}>
              {age}
            </span>
          ))}
        </div>
        <div className={styles.duration}>
          所要時間: {formatDuration(event.duration)}
        </div>
      </div>
      
      <div className={styles.eventFooter}>
        <div className={styles.views}>
          <span className={styles.viewsCount}>{event.views || 0}</span> 閲覧
        </div>
        <div className={styles.date}>
          {new Date(event.created_at).toLocaleDateString('ja-JP')}
        </div>
      </div>
    </div>
  );

  if (loading) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.loadingSpinner} />
        <p>データを読み込んでいます...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className={styles.errorContainer}>
        <p>{error}</p>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <div className={styles.contentWrapper}>
        <header className={styles.header}>
          <h1 className={styles.pageTitle}>イベント一覧</h1>
          <div className={styles.headerButtons}>
            <button 
              type="button"
              onClick={handleLogout} 
              className={styles.logoutButton}
            >
              ログアウト
            </button>
            <Link 
              href="/main" 
              className={styles.backButton}
              prefetch={false}
            >
              カレンダーに戻る
            </Link>
          </div>
        </header>

        <div className={styles.searchSection}>
          <form onSubmit={handleSearch} className={styles.searchBar}>
            <input
              type="text"
              placeholder="イベントを検索..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className={styles.searchInput}
              autoComplete="off"
            />
            <div className={styles.searchButtons}>
              <button 
                type="submit" 
                className={styles.searchButton}
              >
                検索
              </button>
              <button
                type="button"
                onClick={() => setShowAdvancedSearch(true)}
                className={styles.advancedSearchButton}
              >
                詳細検索
              </button>
            </div>
          </form>
          <div className={styles.sortContainer}>
            <button
              type="button"
              className={`${styles.sortButton} ${sortType === 'date' ? styles.active : ''}`}
              onClick={() => handleSort('date')}
            >
              日付順
            </button>
            <button
              type="button"
              className={`${styles.sortButton} ${sortType === 'popular' ? styles.active : ''}`}
              onClick={() => handleSort('popular')}
            >
              人気順
            </button>
          </div>
        </div>

        <div className={styles.eventsGrid}>
          {filteredEvents.map(renderEventCard)}
            </div>
        </div>
        
      {selectedEvent && isOverlayOpen && (
        <EventOverlay
          event={selectedEvent}
          onClose={() => {
            setSelectedEvent(null);
            setIsOverlayOpen(false);
          }}
          onDelete={handleEventDelete}
          onEdit={handleEventEdit}
          season={getSeason(Number(selectedEvent.month))}
        />
      )}

      {editingEvent && (
        <div className={styles.modalOverlay} onClick={handleModalOverlayClick}>
          <div className={styles.modalContent} onClick={e => e.stopPropagation()}>
            <div className={styles.modalHeader}>
              <h2>イベントの編集</h2>
            </div>
            <EditEventForm
              data={{
                title: editingEvent.title,
                description: editingEvent.description,
                category: editingEvent.category,
                month: editingEvent.month,
                date: editingEvent.date,
                duration: editingEvent.duration,
                materials: editingEvent.materials || [],
                objectives: editingEvent.objectives || [],
                age_groups: editingEvent.age_groups,
                media_files: []
              }}
              onSubmit={handleEditEventSubmit}
              onCancel={handleEditCancel}
            />
          </div>
        </div>
      )}

      {/* 詳細検索モーダル */}
      {showAdvancedSearch && (
        <div className={styles.modalOverlay} onClick={closeAdvancedSearch}>
          <div className={styles.modalContent} onClick={e => e.stopPropagation()}>
            <h2 className={styles.modalTitle}>詳細検索</h2>
            <div className={styles.modalBody}>
              <div className={styles.formGroup}>
                <label htmlFor="title">タイトル</label>
                <input
                  id="title"
                  name="title"
                  type="text"
                  value={advancedFilters.title}
                  onChange={e => setAdvancedFilters({...advancedFilters, title: e.target.value})}
                  placeholder="タイトルで検索"
                />
              </div>
              
              <div className={styles.formGroup}>
                <label htmlFor="description">説明文</label>
                <input
                  id="description"
                  name="description"
                  type="text"
                  value={advancedFilters.description}
                  onChange={e => setAdvancedFilters({...advancedFilters, description: e.target.value})}
                  placeholder="説明文で検索"
                />
              </div>
              
              <div className={styles.formGroup}>
                <label>カテゴリー</label>
                <select
                  value={advancedFilters.category}
                  onChange={e => setAdvancedFilters({...advancedFilters, category: e.target.value})}
                >
                  <option value="">すべて</option>
                  <option value="壁　面">壁　面</option>
                  <option value="制作物">制作物</option>
                  <option value="その他">その他</option>
                </select>
              </div>
              
              <div className={styles.formGroup}>
                <label>対象年齢</label>
                <div className={styles.checkboxGroup}>
                  {AGE_GROUPS.map(age => (
                    <label key={age} className={styles.checkboxLabel}>
                      <input
                        type="checkbox"
                        checked={advancedFilters.ageGroups.includes(age)}
                        onChange={e => {
                          if (e.target.checked) {
                            setAdvancedFilters({
                              ...advancedFilters,
                              ageGroups: [...advancedFilters.ageGroups, age]
                            });
                          } else {
                            setAdvancedFilters({
                              ...advancedFilters,
                              ageGroups: advancedFilters.ageGroups.filter(a => a !== age)
                            });
                          }
                        }}
                      />
                      {age}
                    </label>
                  ))}
                </div>
              </div>
              
              <div className={styles.formGroup}>
                <label>所要時間</label>
                <input
                  type="text"
                  value={advancedFilters.duration}
                  onChange={e => setAdvancedFilters({...advancedFilters, duration: e.target.value})}
                  placeholder="例: 30分"
                />
              </div>
              
              <div className={styles.formGroup}>
                <label>準備物</label>
                <input
                  type="text"
                  value={advancedFilters.materials.join('、')}
                  onChange={e => {
                    const items = e.target.value.split(/[、・\s]+/).filter(item => item.trim() !== '');
                    setAdvancedFilters({...advancedFilters, materials: items});
                  }}
                  placeholder="例: 画用紙、クレヨン"
                />
              </div>
              
              <div className={styles.formGroup}>
                <label>目的</label>
                <input
                  type="text"
                  value={advancedFilters.objectives.join('、')}
                  onChange={e => {
                    const items = e.target.value.split(/[、・\s]+/).filter(item => item.trim() !== '');
                    setAdvancedFilters({...advancedFilters, objectives: items});
                  }}
                  placeholder="例: 創造性を育む、手先の器用さを養う"
                />
              </div>
              
              <div className={styles.formGroup}>
                <label>メディア</label>
                <div className={styles.checkboxGroup}>
                  <label className={styles.checkboxLabel}>
                    <input
                      type="checkbox"
                      checked={advancedFilters.hasImage}
                      onChange={e => setAdvancedFilters({...advancedFilters, hasImage: e.target.checked})}
                    />
                    画像ありのみ表示
                  </label>
                  <label className={styles.checkboxLabel}>
                    <input
                      type="checkbox"
                      checked={advancedFilters.hasVideo}
                      onChange={e => setAdvancedFilters({...advancedFilters, hasVideo: e.target.checked})}
                    />
                    動画ありのみ表示
                  </label>
                </div>
              </div>
            </div>
            
            <div className={styles.modalFooter}>
              <button 
                className={styles.resetButton} 
                onClick={resetAdvancedFilters}
              >
                リセット
              </button>
              <button 
                className={styles.cancelButton} 
                onClick={closeAdvancedSearch}
              >
                キャンセル
              </button>
              <button 
                className={styles.applyButton} 
                onClick={applyAdvancedFilters}
              >
                適用
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/main/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';
import styles from './page.module.css';
import MonthCard from '../components/MonthCard';
import EventOverlay from '../components/EventOverlay';
import AddEventForm from '../components/AddEventForm';
import EditEventForm from '../components/EditEventForm';
import { Event, EventFormData, Category, AgeGroup, MediaFile, Duration, LocalEventFormData } from '../types/event';
import Link from 'next/link';
import { months } from '../utils/constants';
import { v4 as uuidv4 } from 'uuid';

// 編集フォームからのデータを受け取るための型
type EditFormData = Omit<EventFormData, 'media_files'> & {
  media_files: (MediaFile | File)[];
};

const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export default function MainPage() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  const [showAddForm, setShowAddForm] = useState(false);
  const [showEditForm, setShowEditForm] = useState(false);
  const [selectedMonth, setSelectedMonth] = useState<number | null>(null);
  const [feedback, setFeedback] = useState<{
    message: string;
    type: 'success' | 'error' | 'warning';
  } | null>(null);
  const [newEventId, setNewEventId] = useState<string | null>(null);
  const router = useRouter();

  const getMonthNumber = (monthName: string): number => {
    const monthStr = monthName.replace('月', '');
    const month = parseInt(monthStr);
    return month;
  };

  // イベントを取得する関数
  async function fetchEvents() {
    try {
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();

      if (sessionError) {
        setError('セッションの取得に失敗しました');
        return;
      }

      if (!session) {
        router.push('/');
        return;
      }

      // イベントデータの取得
      const { data: eventsData, error: eventsError } = await supabase
        .from('events')
        .select(`
          *,
          profiles (
            name
          )
        `)
        .order('created_at', { ascending: false });

      if (eventsError) {
        setError('イベントの取得中に予期せぬエラーが発生しました');
        return;
      }

      if (eventsData) {
        // イベントデータを処理
        const processedEvents = eventsData.map(event => {
          let eventDuration = event.duration;

          // null/undefined チェック
          if (!eventDuration) {
            return {
              ...event,
              isOwner: event.user_id === session.user.id,
              profiles: event.profiles || null,
              duration: { start: '00:00', end: '00:00' }
            };
          }

          // 文字列の場合
          if (typeof eventDuration === 'string') {
            // JSONかどうか判断（{で始まる場合のみパース試行）
            if (eventDuration.trim().startsWith('{')) {
              try {
                eventDuration = JSON.parse(eventDuration);
              } catch (e) {
                // JSONパースに失敗した場合は時間文字列として処理
                const durationStr = eventDuration as string;
                const hoursMatch = durationStr.match(/(\d+)時間/);
                const minutesMatch = durationStr.match(/(\d+)分/);
                
                const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                
                // 時間が取得できた場合
                if (hours > 0 || minutes > 0) {
                  if (hours > 0 && minutes > 0) {
                    eventDuration = `${hours}時間${minutes}分`;
                  } else if (hours > 0) {
                    eventDuration = `${hours}時間`;
                  } else if (minutes > 0) {
                    eventDuration = `${minutes}分`;
                  }
                } else {
                  // 時間が取得できなかった場合はデフォルト値
                  eventDuration = { start: '00:00', end: '00:00' };
                }
              }
            } else {
              // JSONではない通常の時間文字列
              const durationStr = eventDuration as string;
              const hoursMatch = durationStr.match(/(\d+)時間/);
              const minutesMatch = durationStr.match(/(\d+)分/);
              
              const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
              const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
              
              // 時間が取得できなかった場合はデフォルト値
              if (hours === 0 && minutes === 0) {
                eventDuration = { start: '00:00', end: '00:00' };
              }
            }
          }
          
          // オブジェクトの場合、必要なフィールドの存在を確認
          if (typeof eventDuration === 'object' && (!('start' in eventDuration) || !('end' in eventDuration) || !eventDuration.start || !eventDuration.end)) {
            eventDuration = { start: '00:00', end: '00:00' };
          }

          return {
            ...event,
            isOwner: event.user_id === session.user.id,
            profiles: event.profiles || null,
            duration: eventDuration
          };
        });

        // イベントを月ごとに整理
        processedEvents.forEach(event => {
          const month = event.month;
        });

        setEvents(processedEvents);
      } else {
        setEvents([]);
      }
    } catch (error) {
      setError('イベントの取得中に予期せぬエラーが発生しました');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    fetchEvents();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_IN') {
        fetchEvents();
      } else if (event === 'SIGNED_OUT') {
        setEvents([]);
        router.push('/');
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [router]);

  const handleEventClick = (event: Event) => {
    setSelectedEvent(event);
  };

  const handleCloseOverlay = () => {
    setSelectedEvent(null);
  };

  const handleAddEvent = (month: number) => {
    setSelectedMonth(month);
    setShowAddForm(true);
  };

  // フィードバックメッセージを表示する関数
  const showFeedback = (message: string, type: 'success' | 'error' | 'warning') => {
    setFeedback({ message, type });
    setTimeout(() => setFeedback(null), 3000); // 3秒後に消える
  };

  // イベントの重複をチェックする関数
  const checkDuplicateEvent = (eventData: LocalEventFormData, month: number): boolean => {
    const monthEvents = getEventsForMonth(month);
    return monthEvents.some(existingEvent => 
      existingEvent.title === eventData.title ||
      (existingEvent.description === eventData.description && 
       existingEvent.category === eventData.category)
    );
  };

  const handleAddEventSubmit = async (eventData: LocalEventFormData) => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        showFeedback('認証されていません', 'error');
        return;
      }

      if (selectedMonth === null) {
        showFeedback('月が選択されていません', 'error');
        return;
      }

      // 重複チェック
      if (checkDuplicateEvent(eventData, selectedMonth)) {
        const confirmAdd = window.confirm(
          '似たイベントが既に存在します。それでも追加しますか？'
        );
        if (!confirmAdd) {
          showFeedback('イベントの追加をキャンセルしました', 'warning');
          return;
        }
      }

      // 日付を選択された月の1日に設定
      const date = new Date();
      const year = date.getFullYear();
      date.setMonth(selectedMonth - 1);
      date.setDate(1);
      date.setHours(0, 0, 0, 0);

      if (selectedMonth >= 10) {
        date.setFullYear(year + 1);
      }

      // stringからDuration型に変換（例: "2時間30分" -> { start: "00:00", end: "02:30" }）
      const durationString = eventData.duration;
      const durationObj: Duration = {
        start: "00:00",
        end: "00:00"
      };
      
      // 時間と分を抽出
      const hoursMatch = durationString.match(/(\d+)時間/);
      const minutesMatch = durationString.match(/(\d+)分/);
      
      const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
      const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
      
      // 終了時間を計算
      durationObj.end = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

      // ファイルのアップロード処理
      const files = eventData.media_files;
      const mediaFiles: MediaFile[] = [];
      
      // ファイルサイズの制限（5MB）
      const MAX_FILE_SIZE = 5 * 1024 * 1024;

      // ファイルがある場合のみアップロード処理を実行
      if (files && files.length > 0) {
        try {
          // ファイルをアップロード
          for (const file of files) {
            // ファイルサイズのチェック
            if (file.size > MAX_FILE_SIZE) {
              showFeedback(`ファイル ${file.name} が大きすぎます。5MB以下のファイルを選択してください。`, 'error');
              return;
            }

            // 許可されるファイルタイプ
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
            if (!allowedTypes.includes(file.type)) {
              showFeedback(`ファイル ${file.name} の形式がサポートされていません。`, 'error');
              return;
            }

            // ファイル名を一意にする
            const fileExt = file.name.split('.').pop();
            const fileName = `${session.user.id}/${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
            
            showFeedback(`ファイル ${file.name} をアップロード中...`, 'success');
            
            // ファイルをストレージにアップロード
            const { data: uploadData, error: uploadError } = await supabase.storage
              .from('event-media')
              .upload(fileName, file, {
                cacheControl: '3600',
                upsert: true
              });

            if (uploadError) {
              // アップロードエラーの詳細情報を表示
              showFeedback(`アップロードエラー: ${uploadError.message}`, 'error');
              console.error('ファイルアップロードエラー詳細:', uploadError);
              return;
            }

            if (!uploadData || !uploadData.path) {
              showFeedback('ファイルのアップロードに失敗しました: パスが取得できません', 'error');
              return;
            }

            // アップロードしたファイルのURLを取得
            const { data: urlData } = supabase.storage
              .from('event-media')
              .getPublicUrl(uploadData.path);

            if (!urlData || !urlData.publicUrl) {
              showFeedback('公開URLの取得に失敗しました', 'error');
              return;
            }

            // ファイルタイプを判断
            const type = file.type.startsWith('image/') ? 'image' : 'video';
            
            mediaFiles.push({
              type,
              url: urlData.publicUrl
            });
            
            showFeedback(`ファイル ${file.name} のアップロードが完了しました`, 'success');
          }
        } catch (error) {
          console.error('ファイルアップロード中の例外:', error);
          showFeedback(`ファイルアップロード中にエラーが発生しました: ${error instanceof Error ? error.message : '不明なエラー'}`, 'error');
          return;
        }
      }
      
      // カテゴリーの正規化（全角スペースを保持）
      const normalizedEventData = {
        ...eventData,
        duration: durationObj,
        category: eventData.category.trim()
      };

      const { data, error } = await supabase
        .from('events')
        .insert({
          ...normalizedEventData,
          date: new Date(date).toISOString(), // 常に選択された月の1日を使用
          month: selectedMonth.toString(), // 文字列として保存
          user_id: session.user.id,
          views: 0,
          media_files: mediaFiles // アップロードしたメディアファイル情報を保存
        })
        .select();

      if (error) {
        showFeedback('イベントの追加に失敗しました', 'error');
        return;
      }

      if (data) {
        setNewEventId(data[0].id); // アニメーション用にIDを保存
        showFeedback('イベントを追加しました', 'success');
        await fetchEvents();
        setShowAddForm(false);
        setSelectedMonth(null);

        // 3秒後にアニメーション状態をリセット
        setTimeout(() => setNewEventId(null), 3000);
      }
    } catch (error) {
      showFeedback('予期せぬエラーが発生しました', 'error');
    }
  };

  const handleEditEventSubmit = async (eventData: EditFormData) => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        showFeedback('認証されていません', 'error');
        return;
      }

      if (!selectedEvent) {
        showFeedback('編集するイベントが選択されていません', 'error');
        return;
      }

      // media_filesの中からFileオブジェクトだけを抽出
      const files = eventData.media_files.filter(file => file instanceof File) as File[];
      const existingMediaFiles = eventData.media_files.filter(file => !(file instanceof File) && !('file' in file)) as MediaFile[];
      
      // ファイルサイズの制限（5MB）
      const MAX_FILE_SIZE = 5 * 1024 * 1024;

      // 新しいファイルをアップロード
      const newMediaFiles = await Promise.all(
        files.map(async (file: File) => {
          try {
            // ファイルサイズのチェック
            if (file.size > MAX_FILE_SIZE) {
              throw new Error(`ファイル ${file.name} が大きすぎます。5MB以下のファイルを選択してください。`);
            }

            // 許可されるファイルタイプ
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
            if (!allowedTypes.includes(file.type)) {
              throw new Error(`ファイル ${file.name} の形式がサポートされていません。`);
            }

            // ファイル名を一意にする
            const fileExt = file.name.split('.').pop();
            const fileName = `${session.user.id}/${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
            
            showFeedback(`ファイル ${file.name} をアップロード中...`, 'success');
            
            // ファイルをストレージにアップロード
            const { data: uploadData, error: uploadError } = await supabase.storage
              .from('event-media')
              .upload(fileName, file, {
                cacheControl: '3600',
                upsert: true
              });

            if (uploadError) {
              showFeedback(`アップロードエラー: ${uploadError.message}`, 'error');
              console.error('ファイルアップロードエラー詳細:', uploadError);
              throw uploadError;
            }
            
            if (!uploadData || !uploadData.path) {
              throw new Error('ファイルのアップロードに失敗しました: パスが取得できません');
            }

            // アップロードしたファイルのURLを取得
            const { data: urlData } = supabase.storage
              .from('event-media')
              .getPublicUrl(uploadData.path);

            if (!urlData || !urlData.publicUrl) {
              throw new Error('公開URLの取得に失敗しました');
            }

            // ファイルタイプを判断
            const type = file.type.startsWith('image/') ? 'image' : 'video';
            
            showFeedback(`ファイル ${file.name} のアップロードが完了しました`, 'success');
            
            return {
              type,
              url: urlData.publicUrl
            } as MediaFile;
          } catch (error) {
            console.error('ファイル処理エラー:', error);
            throw error;
          }
        })
      );

      // 既存のメディアファイルと新しくアップロードしたファイルを結合
      const allMediaFiles = [...existingMediaFiles, ...newMediaFiles];

      // durationが文字列の場合は"X時間Y分"形式に変換
      let durationStr = '';
      if (typeof eventData.duration === 'object') {
        // オブジェクト形式の場合は時間と分を抽出
        const end = eventData.duration.end;
        if (end) {
          const timeMatch = end.match(/^(\d{1,2}):(\d{1,2})$/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            
            if (hours > 0) {
              durationStr += `${hours}時間`;
            }
            
            if (minutes > 0) {
              durationStr += `${minutes}分`;
            }
          }
        }
      } else {
        // すでに文字列の場合はそのまま使用
        durationStr = eventData.duration;
      }

      // 更新データの作成
      const updateData = {
        ...eventData,
        media_files: allMediaFiles,
        duration: durationStr || '不明',
        month: String(eventData.month),
        updated_at: new Date().toISOString()
      };

      // データベース更新
      const { data, error } = await supabase
        .from('events')
        .update(updateData)
        .eq('id', selectedEvent.id)
        .select();

      if (error) {
        console.error('イベント更新エラー:', error);
        showFeedback('イベントの更新に失敗しました', 'error');
        return;
      }

      await fetchEvents();
      setSelectedEvent(null);
      setShowEditForm(false);
      showFeedback('イベントを更新しました', 'success');
    } catch (error) {
      console.error('Error:', error);
      showFeedback(error instanceof Error ? error.message : 'ファイルのアップロード中にエラーが発生しました', 'error');
    }
  };

  const handleDeleteEvent = async (id: string) => {
    try {
      const { error } = await supabase
        .from('events')
        .delete()
        .eq('id', id);

      if (error) throw error;

      setEvents(events.filter(event => event.id !== id));
      setSelectedEvent(null);
    } catch (error) {
      console.error('Error deleting event:', error);
      setError('イベントの削除に失敗しました');
    }
  };

  const getEventsForMonth = (month: number) => {
    const monthEvents = events.filter(event => {
      // 文字列型の月を数値に変換して比較（互換性のため）
      const eventMonth = Number(event.month);
      const isMatch = eventMonth === month;
      return isMatch;
    });
    
    return monthEvents;
  };

  const convertEventToFormData = (event: Event): EventFormData => {
    return {
      id: event.id,
      title: event.title,
      description: event.description,
      category: event.category,
      month: event.month,
      date: event.date,
      duration: event.duration,
      materials: event.materials,
      objectives: event.objectives,
      age_groups: event.age_groups,
      media_files: event.media_files
    };
  };

  if (loading) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.loadingSpinner} />
        <p>データを読み込んでいます...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className={styles.errorContainer}>
        <p>{error}</p>
        <button onClick={fetchEvents} className={styles.retryButton}>
          再試行
        </button>
      </div>
    );
  }

  const getSeason = (monthStr: string) => {
    const monthNumber = monthStr.replace('月', '');
    const month = parseInt(monthNumber);
    if ([4, 5, 6].includes(month)) return 'spring';    // 4-6月：春
    if ([7, 8, 9].includes(month)) return 'summer';    // 7-9月：夏
    if ([10, 11, 12].includes(month)) return 'autumn'; // 10-12月：秋
    return 'winter';                                   // 1-3月：冬
  };

  // EventBaseからEventへの変換関数
  const convertToEvent = (eventBase: any, id?: string): Event => {
    const defaultDate = new Date();
    defaultDate.setDate(1);
    
    let eventDuration = eventBase.duration;

    // null/undefined チェック
    if (!eventDuration) {
      eventDuration = { start: '00:00', end: '00:00' };
    } else if (typeof eventDuration === 'string') {
      // JSONかどうか判断（{で始まる場合のみパース試行）
      if (eventDuration.trim().startsWith('{')) {
        try {
          eventDuration = JSON.parse(eventDuration);
        } catch (e) {
          // JSONパースに失敗した場合は時間文字列として処理
          const durationStr = eventDuration as string;
          const hoursMatch = durationStr.match(/(\d+)時間/);
          const minutesMatch = durationStr.match(/(\d+)分/);
          
          const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
          const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
          
          // 時間が取得できた場合
          if (hours > 0 || minutes > 0) {
            if (hours > 0 && minutes > 0) {
              eventDuration = `${hours}時間${minutes}分`;
            } else if (hours > 0) {
              eventDuration = `${hours}時間`;
            } else if (minutes > 0) {
              eventDuration = `${minutes}分`;
            }
          } else {
            // 時間が取得できなかった場合はデフォルト値
            eventDuration = { start: '00:00', end: '00:00' };
          }
        }
      } else {
        // JSONではない通常の時間文字列
        const durationStr = eventDuration as string;
        const hoursMatch = durationStr.match(/(\d+)時間/);
        const minutesMatch = durationStr.match(/(\d+)分/);
        
        const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
        const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
        
        // 時間が取得できなかった場合はデフォルト値
        if (hours === 0 && minutes === 0) {
          eventDuration = { start: '00:00', end: '00:00' };
        }
      }
    }
    
    // オブジェクトの場合、必要なフィールドの存在を確認
    if (typeof eventDuration === 'object' && (!('start' in eventDuration) || !('end' in eventDuration) || !eventDuration.start || !eventDuration.end)) {
      eventDuration = { start: '00:00', end: '00:00' };
    }

    return {
      ...eventBase,
      id: id || uuidv4(),
      views: 0,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      user_id: '',
      isOwner: true,
      profiles: null,
      duration: eventDuration
    };
  };

  return (
    <div className={styles.container}>
      {feedback && (
        <div className={`${styles.feedbackMessage} ${styles[feedback.type]}`}>
          {feedback.message}
        </div>
      )}
      
      <div className={styles.headerWrapper}>
        <header className={styles.header}>
          <h1 className={styles.title}>保育アイデア管理</h1>
          <div className={styles.headerButtons}>
            <Link href="/events" className={styles.viewAllLink}>
              すべてのイベントを見る
            </Link>
            <button
              onClick={() => {
                // すべてのクッキーを削除
                document.cookie.split(";").forEach(c => {
                  const key = c.trim().split("=")[0];
                  if (key) {
                    document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
                  }
                });
                
                // Supabase関連のローカルストレージをクリア
                localStorage.removeItem('supabase.auth.token');
                localStorage.removeItem('supabase.auth.expires_at');
                localStorage.removeItem('supabase.auth.refresh_token');
                
                // ページをリロード
                window.location.href = '/';
              }}
              className={styles.logoutButton}
            >
              ログアウト
            </button>
          </div>
        </header>
      </div>

      <div className={styles.descriptionContainer}>
        <p className={styles.description}>
          このアプリケーションは、保育士の方々が年間を通じて行うイベントやアクティビティのアイディアを管理するためのツールです。<br />
          月ごとにイベントを追加・編集・削除することができ、各イベントには目的、準備物、所要時間などの詳細な情報を記録できます。
        </p>
      </div>

      <div className={styles.monthGrid}>
        {months.map((monthName) => {
          const month = getMonthNumber(monthName);
          const monthEvents = getEventsForMonth(month);
          return (
            <MonthCard
              key={`month-${month}`}
              month={month}
              monthName={monthName}
              events={monthEvents}
              onEventClick={handleEventClick}
              onAddClick={() => handleAddEvent(month)}
              season={getSeason(monthName)}
              newEventId={newEventId}
            />
          );
        })}
      </div>

      {selectedEvent && (
        <EventOverlay
          event={selectedEvent}
          onClose={handleCloseOverlay}
          onEdit={() => setShowEditForm(true)}
          onDelete={() => handleDeleteEvent(selectedEvent.id)}
          season={getSeason(months[parseInt(selectedEvent.month) - 1])}
        />
      )}

      {showAddForm && selectedMonth !== null && (
        <AddEventForm
          onSubmit={handleAddEventSubmit}
          onCancel={() => {
            setShowAddForm(false);
            setSelectedMonth(null);
          }}
          selectedMonth={selectedMonth}
        />
      )}

      {showEditForm && selectedEvent && (
        <div className={styles.overlay}>
          <div className={styles.modal}>
            <EditEventForm
              data={convertEventToFormData(selectedEvent)}
              onSubmit={handleEditEventSubmit}
              onCancel={() => setShowEditForm(false)}
            />
          </div>
        </div>
      )}
    </div>
  );
}
</file>

</files>
